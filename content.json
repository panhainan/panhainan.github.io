{"meta":{"title":"十六子","subtitle":"个人技术博客","description":"潘海南的个人技术博客，记录平时的笔记。","author":"潘海南","url":"http://panhainan.github.io","root":"/"},"pages":[{"title":"关于","date":"2018-03-19T14:18:26.000Z","updated":"2018-03-23T17:31:51.477Z","comments":true,"path":"about/index.html","permalink":"http://panhainan.github.io/about/index.html","excerpt":"","text":"潘海南（十六子，FireOct），2016年7月毕业于长沙理工大学计算机科学与技术专业。 个人经历 一年备战，报考浙大，以2分之差落榜，经历了很多事，想了很久，最后决定还是工作吧。(2017.03.16) 再三思考，从广东亿迅离职，备战考研。 (2017.03.02) 从长沙理工大学毕业，开始码农的职业生涯。(2016.07.01) 大一进入梦之站团队，开始进入了Java的世界。（当时为Java创新实验室，后面组建成梦之站团队）。(2013.03.25) 搬砖经历8. 响应式个人博客系统 2016.11~2017.02 工程项目（SpringMVC、Spring、MyBatis、AngularJS） 一个基于Java的服务器端采用Spring+SpringMVC+Mybatis开发，前端采用BootStrap+AngularJS开发的响应式博客系统。本站即为该博客系统的一个案例。 7. 政府企业部门大数据交换共享平台 2016.08~2017.03 工程项目（SpringMVC、Spring、MyBatis、AngularJS、集群、调度、单点登录、Mule） 在广东亿迅工作期间，6人团队开发的一个用于政府企业等包含多个部门的部门间结构化、非结构化等数据进行交换共享的平台系统，已完结，2017年3月已完全在珠海上线试用。 6. 大学生求职社交平台 2016.02~04 研究项目（SpringMVC、Spring、MyBatis） 本人的毕业设计，一个用于毕业生和企业之间求职招聘的交流平台。前端基于AngularJS、BootStrap，支持不同设备访问屏幕内容自适应，后端基于ssm，数据交互采用JSON。 5. “果动”高校活动平台 2015.01~04 工程项目（SpringMVC、Spring、MyBatis） 目的是为全国各地区高校建立一个同城的活动交流平台；项目在技术上使用前后端分离方法“使用一套服务器提供给网页端和安卓端”。 4. 长理失物招领网 2014.11 研究项目（SpringMVC、Spring、Hibernate） 长理失物招领网，应学校科技立项开展开发的一个用于失物招领的平台。 3. O2O网上书城 2014.11 研究项目（SpringMVC、Spring、MyBatis） 应电子商务课程要求设计的一个O2O网上书城，是一个类似于当当网的一个网上书籍交易平台，是当时电子商务课程里2星期内个人完成的最好的作品。 2. DS-Java论坛系统 2014.05~07 研究项目（Struts2、Spring、Hibernate） 独自模拟IT技术论坛开发的技术交流论坛；获得“软件著作权、“计算机设计大赛中南地区二等奖”和“计算机设计大赛全国三等奖”。 1. 梦之站团队官网（v1和v2） 2013.06~10 &amp; 2015.06~07 工程项目（Struts2、Spring、Hibernate） 长沙理工大学梦之站团队（Java创新实验室）的官方网站；获得“软件著作权”、“计算机设计大赛国家二等奖、中南地区三等奖”。于2015.6月由本人重写改版为V2，改版内容：增加团队内部管理的一些功能，删减一些实用性不大的资讯模块等。 联系我 Q Q：1016593477 邮箱：panhainan@yeah.net"}],"posts":[{"title":"CentOS7安装Docker","slug":"CentOS7安装Docker","date":"2019-09-30T13:00:00.000Z","updated":"2019-09-30T18:49:29.793Z","comments":true,"path":"2019/09/30/CentOS7安装Docker/","link":"","permalink":"http://panhainan.github.io/2019/09/30/CentOS7安装Docker/","excerpt":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的 Linux 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的 Linux 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 1. 检查Linux内核版本Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 使用 root 权限登录 。确保 yum 包更新到最新。 1sudo yum update 2. 卸载旧版本 如果已安装过，就使用以下命令删除，比如删除上图中的docker，命令为： 1yum -y remove docker-ce.x86_64 或者统一删除 1sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 3. 安装必要的工具1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的 4. 设置yum源1sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 5. 查看仓库中所有的Docker版本1yum list docker-ce --showduplicates | sort -r 6. 安装Docker选择特定版本，比如我选择的是docker-ce-17.12.0.ce版本 1sudo yum install docker-ce-17.12.0.ce 7. 验证是否安装完毕1docker version 8. 开启开机自启12sudo systemctl start dockersudo systemctl enable docker 9. 安装常见问题若出现如下类似问题，就是表明系统中存在旧版本的Docker，与正在安装的版本产生冲突，需要卸载删除旧版本后才能继续安装。 123Transaction check error: file /usr/bin/docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-... ... 卸载操作可以采用上述第2步的操作，或者使用一下命令 1sudo yum erase docker-common-... 注意 docker-common-… 为错误日志中出现的版本号","categories":[{"name":"Docker","slug":"Docker","permalink":"http://panhainan.github.io/categories/Docker/"},{"name":"Linux","slug":"Docker/Linux","permalink":"http://panhainan.github.io/categories/Docker/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://panhainan.github.io/tags/Docker/"}]},{"title":"CentOS7防火墙相关操作命令","slug":"CentOS7防火墙操作","date":"2019-09-30T12:30:00.000Z","updated":"2019-09-30T18:49:29.794Z","comments":true,"path":"2019/09/30/CentOS7防火墙操作/","link":"","permalink":"http://panhainan.github.io/2019/09/30/CentOS7防火墙操作/","excerpt":"防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，为用户提供更好、更安全的计算机网络使用体验。","text":"防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，为用户提供更好、更安全的计算机网络使用体验。 1. 查看防火墙状态1firewall-cmd --state running表示已开启 not running表示已关闭 或者使用 1systemctl status firewalld.service 2. 开启防火墙1systemctl start firewalld.service 3. 设置开机自启1systemctl enable firewalld.serivce 4. 查看防火墙是否开机自启成功1systemctl is-enabled firewalld.service;echo $? 5. 关闭防火墙1systemctl stop firewalld.service 6. 开启特定端口1firewall-cmd --zone=public --add-port=port/tcp --permanent –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 比如，开启80、3306、6379等端口 7. 查看所有开放防火墙的端口1firewall-cmd --list-ports","categories":[{"name":"Linux","slug":"Linux","permalink":"http://panhainan.github.io/categories/Linux/"}],"tags":[{"name":"防火墙","slug":"防火墙","permalink":"http://panhainan.github.io/tags/防火墙/"}]},{"title":"《程序员代码面试指南》用一个辅助栈实现另一个栈的排序","slug":"《程序员代码面试指南》用一个辅助栈实现另一个栈的排序","date":"2018-08-26T15:40:00.000Z","updated":"2019-09-30T18:49:29.804Z","comments":true,"path":"2018/08/26/《程序员代码面试指南》用一个辅助栈实现另一个栈的排序/","link":"","permalink":"http://panhainan.github.io/2018/08/26/《程序员代码面试指南》用一个辅助栈实现另一个栈的排序/","excerpt":"一个栈中的元素类型为整型，现在将该栈从栈顶到栈底按从大到小的顺序排序，只允许申请一个辅助栈。如何利用好这个辅助栈是这道题的解题关键所在。","text":"一个栈中的元素类型为整型，现在将该栈从栈顶到栈底按从大到小的顺序排序，只允许申请一个辅助栈。如何利用好这个辅助栈是这道题的解题关键所在。 用一个辅助栈实现另一个栈的排序 如何利用好这个辅助栈是这道题的解题关键所在。 题目 一个栈中的元素类型为整型，现在将该栈从栈顶到栈底按从大到小的顺序排序，只允许申请一个辅助栈。除此之外可以申请新的变量，但不能申请额外的数据结构。如何完成排序？ 实现思想 假设存有数据的栈名A，辅助栈为B； 首先pop出A栈栈顶元素，将其push到B栈中； 接着，继续pop出A栈栈顶元素保存在变量cur中，然后和B栈栈顶元素（temp）比较： 1）若cur&gt;temp，则将temp元素pop出B栈，push入A栈，继续和B栈栈顶元素进行上述的比较； 2）若cur&lt;=temp ，则直接将cur元素push入B栈内； 继续第2步操作直至A栈空，然后将B栈元素一一push入A栈。 至此，排序完毕，A栈元素即是排序后的结果。 #代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243package site.sixteen.stack_queue;import java.util.Stack;/** * StackSortByStack * * @author panhainan@yeah.net(@link https://sixteen.site) * @version 1.0 * @use 用一个辅助栈实现另一个栈的排序 * @date 2018/8/27 **/public class StackSortByStack &#123; public static void stackSortByStack(Stack&lt;Integer&gt; dataStack) &#123; Stack&lt;Integer&gt; assistStack = new Stack&lt;&gt;(); Integer cur; while (!dataStack.empty()) &#123; cur = dataStack.pop(); while (!assistStack.empty() &amp;&amp; assistStack.peek() &lt; cur) &#123; dataStack.push(assistStack.pop()); &#125; assistStack.push(cur); &#125; while (!assistStack.empty()) &#123; dataStack.push(assistStack.pop()); &#125; &#125; public static void main(String[] args) &#123; Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); data.push(3); data.push(4); data.push(2); data.push(1); data.push(5); stackSortByStack(data); while (!data.empty()) &#123; System.out.println(data.pop()); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://panhainan.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://panhainan.github.io/tags/算法/"},{"name":"栈排序","slug":"栈排序","permalink":"http://panhainan.github.io/tags/栈排序/"}]},{"title":"《程序员代码面试指南》两个栈实现队列","slug":"《程序员代码面试指南》两个栈实现队列","date":"2018-08-24T15:46:07.000Z","updated":"2019-09-30T18:49:29.804Z","comments":true,"path":"2018/08/24/《程序员代码面试指南》两个栈实现队列/","link":"","permalink":"http://panhainan.github.io/2018/08/24/《程序员代码面试指南》两个栈实现队列/","excerpt":"这是一道面试很常见的算法题，首先要熟悉栈和队列的特点，栈是先进后出，队列是先进先出。","text":"这是一道面试很常见的算法题，首先要熟悉栈和队列的特点，栈是先进后出，队列是先进先出。 编写一个类，用两个栈实现队列，支持队列的基本操作（add，poll，peek） 栈和队列的特点，栈是先进后出，队列是先进先出。 题目编写一个类，用两个栈实现队列，支持队列的基本操作（add，poll，peek） #实现思想： 用两个栈A，B； A用来存储进行add操作的元素；每次add都将元素压入A栈中； B则是用来存储进行poll和peek操作的元素，这些元素都是从A栈中来的；每次进行poll和peek操作时，先判断B栈是否为空；若不为空，则将栈顶元素pop出来或者peek出来；若为空，则将A栈中的元素一一push到B栈中，直到A栈为空时，停止push操作，然后将B栈栈顶元素pop出来或peek出来；这样实现的顺序正好是队列先进先出的情况。 如下图解释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package site.sixteen.stack_queue;import java.util.Stack;/** * TowStackQueue * * @author panhainan@yeah.net(@link https://sixteen.site) * @version 1.0 * @use 两个栈实现队列 * @date 2018/8/22 **/public class TowStackQueue&lt;T&gt; &#123; /** * 入队栈 */ private Stack&lt;T&gt; stackIn; /** * 出队栈 */ private Stack&lt;T&gt; stackOut; public TowStackQueue() &#123; stackIn = new Stack&lt;&gt;(); stackOut = new Stack&lt;&gt;(); &#125; /** * @param t 入队元素 * @use 入队 */ public void add(T t) &#123; stackIn.push(t); &#125; /** * @return 出队元素 * @use 出队 */ public T poll() &#123; stackInToStackOut(); return stackOut.pop(); &#125; /** * 取队头元素 * * @return 队头元素 */ public T peek() &#123; stackInToStackOut(); return stackOut.peek(); &#125; /** * 判断队列是否为空 * * @return */ public boolean empty() &#123; return stackOut.empty() &amp;&amp; stackIn.empty(); &#125; /** * 获取队列大小 * * @return 队列大小 */ public int size() &#123; return stackOut.size() + stackIn.size(); &#125; private void stackInToStackOut() &#123; if (empty()) &#123; throw new RuntimeException(\"Queue is empty!\"); &#125; else if (stackOut.empty()) &#123; while (!stackIn.empty()) &#123; stackOut.push(stackIn.pop()); &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://panhainan.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://panhainan.github.io/tags/算法/"},{"name":"两个栈实现队列","slug":"两个栈实现队列","permalink":"http://panhainan.github.io/tags/两个栈实现队列/"}]},{"title":"Java 使用 Apache POI 生成及解析 Excel","slug":"Java使用ApachePOI生成及解析Excel","date":"2018-08-15T15:25:28.000Z","updated":"2019-09-30T18:49:29.796Z","comments":true,"path":"2018/08/15/Java使用ApachePOI生成及解析Excel/","link":"","permalink":"http://panhainan.github.io/2018/08/15/Java使用ApachePOI生成及解析Excel/","excerpt":"Java 使用 Apache POI 生成及解析 Excel本文简单介绍一下Apache POI工具包如何生存以及解析Excel表格。","text":"Java 使用 Apache POI 生成及解析 Excel本文简单介绍一下Apache POI工具包如何生存以及解析Excel表格。 Apache POI 库的基本定义 HSSF`在类名前面加上前缀，以指示与Microsoft Excel 2003文件相关的操作。 XSSF`在类名前面加前缀，表示与Microsoft Excel 2007文件或更高版本相关的操作。 XSSFWorkbook`和HSSFWorkbook是充当Excel工作簿的类 HSSFSheet`和XSSFSheet是充当Excel工作表的类 Row定义Excel行 Cell定义了一个引用行的Excel单元格。 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt;&lt;/dependency&gt; 实例 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package site.sixteen.demoutils;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.*;import java.util.Iterator;public class ApachePOIUtils &#123; public static void writeToExcel(Object[][] data, String fileName) throws IOException &#123; XSSFWorkbook workbook = new XSSFWorkbook(); XSSFSheet sheet = workbook.createSheet(\"A班\"); int rowNum = 0; for (Object[] list : data) &#123; Row row = sheet.createRow(rowNum++); int colNum = 0; for (Object value : list) &#123; Cell cell = row.createCell(colNum++); if (value instanceof String) &#123; cell.setCellValue((String) value); &#125; else if (value instanceof Integer) &#123; cell.setCellValue((Integer) value); &#125; else if (value instanceof Boolean) &#123; cell.setCellValue((boolean) value); &#125; else &#123; cell.setCellValue(String.valueOf(value)); &#125; &#125; &#125; try (FileOutputStream outputStream = new FileOutputStream(fileName)) &#123; workbook.write(outputStream); &#125; &#125; public static void readExcel(File file) throws IOException &#123; FileInputStream excelFile = new FileInputStream(file); Workbook workbook = new XSSFWorkbook(excelFile); Sheet sheet = workbook.getSheetAt(0); Iterator&lt;Row&gt; rowIterator = sheet.rowIterator(); while (rowIterator.hasNext()) &#123; Row row = rowIterator.next(); Iterator&lt;Cell&gt; cellIterator = row.cellIterator(); while (cellIterator.hasNext()) &#123; Cell cell = cellIterator.next(); if (cell.getCellTypeEnum() == CellType.STRING) &#123; System.out.print(cell.getStringCellValue() + \"\\t\"); &#125; else if (cell.getCellTypeEnum() == CellType.NUMERIC) &#123; System.out.print(cell.getNumericCellValue() + \"\\t\"); &#125; else if(cell.getCellTypeEnum() == CellType.BOOLEAN)&#123; System.out.print(cell.getBooleanCellValue() + \"\\t\"); &#125; else &#123; System.out.print(cell.getStringCellValue() + \"\\t\"); &#125; &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; Object[][] datas = &#123; &#123;\"编号\", \"名字\", \"年龄\", \"性别\"&#125;, &#123;\"001\", \"Tom\", 18, true&#125;, &#123;\"002\", \"Jac\", 10, true&#125;, &#123;\"003\", \"Oct\", 24, true&#125;, &#123;\"004\", \"Lil\", 21, false&#125;, &#125;; String fileName = \"/tmp/demo-write.xlsx\"; try &#123; writeToExcel(datas, fileName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; readExcel(new File(fileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 生成的Excel在/tmp/demo-write.xlsx 解析的结果： 1234567编号 名字 年龄 性别 001 Tom 18.0 true 002 Jac 10.0 true 003 Oct 24.0 true 004 Lil 21.0 false Process finished with exit code 0","categories":[{"name":"ApachePOI","slug":"ApachePOI","permalink":"http://panhainan.github.io/categories/ApachePOI/"}],"tags":[{"name":"Excel处理","slug":"Excel处理","permalink":"http://panhainan.github.io/tags/Excel处理/"}]},{"title":"Shiro整入SpringMVC简单Demo","slug":"Shiro+SpringMVC简单Demo","date":"2018-08-13T15:45:00.000Z","updated":"2019-09-30T18:49:29.800Z","comments":true,"path":"2018/08/13/Shiro+SpringMVC简单Demo/","link":"","permalink":"http://panhainan.github.io/2018/08/13/Shiro+SpringMVC简单Demo/","excerpt":"在权限框架这块，用了一段时间Shiro，这里记录了一下笔记，主要是将Shiro初步整入了SpringMVC项目，该项目没有实际连接数据库，采用模拟数据进行，主要实现了认证授权功能。","text":"在权限框架这块，用了一段时间Shiro，这里记录了一下笔记，主要是将Shiro初步整入了SpringMVC项目，该项目没有实际连接数据库，采用模拟数据进行，主要实现了认证授权功能。 Shiro以下概念参考来自 https://legacy.gitbook.com/book/waylau/apache-shiro-1-2-x-reference/details 简介 Apache Shiro是一个功能强大、灵活的，开源的安全框架。 Authentication（认证）, Authorization（授权）, Session Management（会话管理）, Cryptography（加密）被 Shiro 框架的开发团队称之为应用安全的四大基石 。 Authentication（认证）：用户身份识别，通常被称为用户“登录” Authorization（授权）：访问控制。比如某个用户是否具有某个操作的使用权限。 Session Management（会话管理）：特定于用户的会话管理,甚至在非web 或 EJB 应用程序。 Cryptography（加密）：在对数据源使用加密算法加密的同时，保证易于使用。 还有其他的功能来支持和加强这些不同应用环境下安全领域的关注点。特别是对以下的功能支持： Web支持：Shiro 提供的 web 支持 api ，可以很轻松的保护 web 应用程序的安全。 缓存：缓存是 Apache Shiro 保证安全操作快速、高效的重要手段。 并发：Apache Shiro 支持多线程应用程序的并发特性。 测试：支持单元测试和集成测试，确保代码和预想的一样安全。 “Run As”：这个功能允许用户假设另一个用户的身份(在许可的前提下)。 “Remember Me”：跨 session 记录用户的身份，只有在强制需要时才需要登录。 架构高级概述在概念层，Shiro 架构包含三个主要的理念：Subject,SecurityManager和 Realm Subject:Subject 本质上是当前运行用户特定的’View’(视图)，而单词“User”经常暗指一个人，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它–当前和软件交互的任何事件。 Subject 实例都和（也需要）一个 SecurityManager 绑定，当你和一个Subject 进行交互，这些交互动作被转换成 SecurityManager 下Subject 特定的交互动作。 SecurityManager: SecurityManager 是 Shiro 架构的核心，配合内部安全组件共同组成安全伞。然而，一旦一个程序配置好了SecurityManager 和它的内部对象，SecurityManager通常独自留下来，程序开发人员几乎花费的所有时间都集中在 Subjet API上。 我们将在以后详细讨论 SecurityManager，但当你和一个 Subject 互动时了解它是很重要的。任何 Subject 的安全操作中 SecurityManager 是幕后真正的举重者，这在上面的图表中可以反映出来。 Realms： Reamls 是 Shiro 和你的程序安全数据之间的“桥”或者“连接”，它用来实际和安全相关的数据如用户执行身份认证（登录）的帐号和授权（访问控制）进行交互，Shiro 从一个或多个程序配置的 Realm 中查找这些东西。 Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个Realm 来实现认证（authentication）和/或授权（authorization）。SecurityManager 可以配置多个复杂的 Realm，但是至少有一个是需要的。 Shiro 提供开箱即用的 Realms 来连接安全数据源（或叫地址）如 LDAP、JDBC、文件配置如INI和属性文件等，如果已有的Realm不能满足你的需求你也可以开发自己的Realm实现。 和其它内部组件一样，Shiro SecurityManager 管理如何使用 Realms获取 Subject 实例所代表的安全和身份信息。 详细架构 Subject (org.apache.shiro.subject.Subject) 正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）。 SecurityManager (org.apache.shiro.mgt.SecurityManager) 如同上面提到的，SecurityManager 是 Shiro 的核心，它基本上就是一把“保护伞”用来协调它管理的组件使之平稳地一起工作，它也管理着 Shiro 中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。 Authenticator(org.apache.shiro.authc.Authenticator) Authenticator 是一个组件，负责执行和反馈用户的认证（登录），如果一个用户尝试登录，Authenticator 就开始执行。Authenticator 知道如何协调一个或多个保存有相关用户/帐号信息的 Realm，从这些 Realm中获取这些数据来验证用户的身份以确保用户确实是其表述的那个人。 Authentication Strategy(org.apache.shiro.authc.pam.AuthenticationStrategy) 如果配置了多个 Realm，AuthenticationStrategy 将会协调 Realm 确定在一个身份验证成功或失败的条件（例如，如果在一个方面验证成功了但其他失败了，这次尝试是成功的吗？是不是需要所有方面的验证都成功？还是只需要第一个？） Authorizer(org.apache.shiro.authz.Authorizer) Authorizer 是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像 Authenticator 一样，Authorizer 也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer 利用这些信息来准确判断一个用户是否可以执行给定的动作。 SessionManager(org.apache.shiro.session.mgt.SessionManager) SessionManager 知道如何创建并管理用户 Session 生命周期而在所有环境中为用户提供一个强有力的 Session 体验。这在安全框架领域是独一无二–Shiro 具备管理在任何环境下管理用户 Session 的能力，即使没有 Web/Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。 SessionDAO(org.apache.shiro.session.mgt.eis.SessionDAO) SessionDAO 代表 SessionManager 执行 Session 持久（CRUD）动作，它允许任何存储的数据挂接到 session 管理基础上。 CacheManager(org.apache.shiro.cache.CacheManager) CacheManager 为 Shiro 的其他组件提供创建缓存实例和管理缓存生命周期的功能。因为 Shiro 的认证、授权、会话管理支持多种数据源，所以访问数据源时，使用缓存来提高访问效率是上乘的选择。当下主流开源或企业级缓存框架都可以继承到 Shiro 中，来获取更快更高效的用户体验。 Cryptography (org.apache.shiro.crypto.*) Cryptography 在安全框架中是一个自然的附加产物，Shiro 的 crypto 包包含了易用且易懂的加密方式，Hashes（即digests）和不同的编码实现。该包里所有的类都亦于理解和使用，曾经用过 Java 自身的加密支持的人都知道那是一个具有挑战性的工作，而 Shiro 的加密 API 简化了 java 复杂的工作方式，将加密变得易用。 Realms (org.apache.shiro.realm.Realm) 如同上面提到的，Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。 Shiro实例Web项目注意：代码贴的顺序可能有些小乱，但是基本上没什么大问题，可以先将实例大致看完，然后进行配置，或者直接前往我的GitHub获取。 地址：https://github.com/panhainan/spring-mvc-shiro-demo 1. 搭建Spring MVC项目快速搭建Spring MVC Web项目 2. 引入Shiro的Jar包在pom.xml文件中加入以下依赖 123456789101112131415161718192021&lt;!-- Spring 整合Shiro需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 3. web.xml中配置Shiro Filter123456789101112131415161718&lt;!-- Shiro Filter is defined in the spring application context: --&gt; &lt;!-- 1. 配置 Shiro 的 shiroFilter. 2. DelegatingFilterProxy 实际上是 Filter 的一个代理对象. 默认情况下, Spring 会到 IOC 容器中查找和 &lt;filter-name&gt; 对应的 filter bean. 也可以通过 targetBeanName 的初始化参数来配置 filter bean 的 id. --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4. 配置Shiro相关配置可以直接在applicationContext.xml文件中添加shiro的配置，这里为方便管理配置，单独将shiro配置作为一个xml文件保存，命名spring-shiro.xml，并在web.xml中引入。 首先修改web.xml中的配置文件扫描，增加,classpath:spring-shiro.xml 12345&lt;!--配置加载Spring容器配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml,classpath:spring-shiro.xml&lt;/param-value&gt; &lt;/context-param&gt; 然后新建spring-shiro.xml，在其中加入以下代码，相关配置说明见其中注释说明， 核心配置为： SecurityManager Realm（进行） LifecycleBeanPostProcessor ShiroFilter（对应web.xml中的过滤器的过滤条件配置） CacheManager（可选） Annotation（开启注解，可选） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置 SecurityManager. --&gt; &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;property name=\"cacheManager\" ref=\"cacheManager\"/&gt; &lt;property name=\"realm\" ref=\"shiroRealm\"/&gt; &lt;/bean&gt; &lt;!-- 配置 CacheManager. 需要加入 ehcache 的 jar 包及配置文件. --&gt; &lt;bean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt; &lt;/bean&gt; &lt;!-- 配置 Realm 直接配置实现了 org.apache.shiro.realm.Realm 接口的 bean --&gt; &lt;bean id=\"shiroRealm\" class=\"site.sixteen.demo.shiro.ShiroRealm\"&gt; &lt;!-- 配置校验时是否对数据加密，加密算法有MD5,SHA1等 --&gt; &lt;property name=\"credentialsMatcher\"&gt; &lt;bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"&gt; &lt;property name=\"hashAlgorithmName\" value=\"MD5\"&gt;&lt;/property&gt; &lt;property name=\"hashIterations\" value=\"1\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 LifecycleBeanPostProcessor. 可以自动的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法. --&gt; &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"/&gt; &lt;!-- 启用 IOC 容器中使用 shiro 的注解. 但必须在配置了 LifecycleBeanPostProcessor 之后才可以使用. --&gt; &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\"/&gt; &lt;bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;/bean&gt; &lt;!-- 配置 ShiroFilter. id 必须和 web.xml 文件中配置的 DelegatingFilterProxy 的 &lt;filter-name&gt; 一致. 若不一致, 则会抛出: NoSuchBeanDefinitionException. 因为 Shiro 会来 IOC 容器中查找和 &lt;filter-name&gt; 名字对应的 filter bean. --&gt; &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;property name=\"loginUrl\" value=\"/login\"/&gt; &lt;property name=\"successUrl\" value=\"/\"/&gt; &lt;property name=\"unauthorizedUrl\" value=\"/unauthorized\"/&gt; &lt;!-- 配置哪些页面需要受保护. 以及访问这些页面需要的权限. 1). anon 可以被匿名访问 2). authc 必须认证(即登录)后才可能访问的页面. 3). logout 登出. 4). roles 角色过滤器 --&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; /login = anon /logout = logout /user/** = roles[user] /manage/** = roles[admin] # everything else requires authentication: /** = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5. 继承Realm类实现认证授权下面代码用到了lombok.jar，可以省去写log实例，getter，setter方法等的编写。 新建一个ShiroRealm类，该类继承自AuthorizingRealm，实现它的认证和授权方法，代码如下， 12345678910111213141516171819202122232425import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;@Slf4jpublic class ShiroRealm extends AuthorizingRealm &#123; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; return null; &#125; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; return null; &#125;&#125; 6. 实现认证Authentication操作认证操作的步骤基本如下： 把 AuthenticationToken 转换为 UsernamePasswordToken 从 UsernamePasswordToken 中来获取 username 调用数据库的方法, 从数据库中查询 username 对应的用户记录 若用户不存在, 则可以抛出 UnknownAccountException 异常 根据用户信息的情况, 决定是否需要抛出其他的 AuthenticationException 异常.（可选） 根据用户的情况, 来构建 AuthenticationInfo 对象并返回. 通常使用的实现类为: SimpleAuthenticationInfo 这里实现认证doGetAuthenticationInfo方法，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940/** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //1. 把 AuthenticationToken 转换为 UsernamePasswordToken UsernamePasswordToken upToken = (UsernamePasswordToken) token; //2. 从 UsernamePasswordToken 中来获取 username String username = upToken.getUsername(); //3. 调用数据库的方法, 从数据库中查询 username 对应的用户记录 log.info(\"从数据库中获取 username: &#123;&#125; 所对应的用户信息.\", username); User dbUser = UserDAO.fetchDataFromDB(username); log.info(\"数据库中 &#123;&#125; 所对应的用户信息为：&#123;&#125; \", username, dbUser); //4. 若用户不存在, 则可以抛出 UnknownAccountException 异常 if (dbUser == null) &#123; throw new UnknownAccountException(\"用户不存在!\"); &#125; //5. 根据用户信息的情况, 决定是否需要抛出其他的 AuthenticationException 异常. if (dbUser.getLocked()) &#123; throw new LockedAccountException(\"用户被锁定!\"); &#125; //6. 根据用户的情况, 来构建 AuthenticationInfo 对象并返回. 通常使用的实现类为: SimpleAuthenticationInfo //以下信息是从数据库中获取的. //1). principal: 认证的实体信息. 可以是 username(通常), 也可以是数据表对应的用户的实体类对象. Object principal = dbUser.getUsername(); //2). credentials: 密码. Object credentials = dbUser.getPassword(); //3). realmName: 当前 realm 对象的 name. 调用父类的 getName() 方法即可 String realmName = getName(); //4). 盐值. 这里以用户名为盐值 ByteSource credentialsSalt = ByteSource.Util.bytes(username); return new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName); &#125; 7. 实现登录认证的其他业务类User.java代码如下 123456789101112131415161718192021package site.sixteen.demo.entity;import lombok.*;import lombok.extern.slf4j.Slf4j;@Slf4j@NoArgsConstructor@AllArgsConstructor@Setter@Getter@ToStringpublic class User &#123; private Integer id; private String username; private String password; private Boolean locked; private String[] roles;&#125; 数据库数据获取模拟类，UserDAO.java： 123456789101112131415161718192021222324252627282930313233343536package site.sixteen.demo.dao;import site.sixteen.demo.entity.User;/** * @author panhainan@yeah.net(@link http://sixteen.site) **/public class UserDAO &#123; /** * 模拟从数据库取数据 * * @param username * @return */ public static User fetchDataFromDB(String username) &#123; //这里假定数据库中有一下数据: // 1,\"test\",\"47ec2dd791e31e2ef2076caf64ed9b3d\"(原串\"123456\"),false,roles&#123;\"user\"&#125; // 2,\"admin\",\"a66abb5684c45962d887564f08346e8d\"(原串\"123456\"),false,roles&#123;\"admin\",\"user\"&#125; // 3,\"tourist\",\"33d2ebfc6787cdb030d04dc940f8f4ed\"(原串\"123456\"),true,roles&#123;\"tourist\"&#125; User dbUser = null; switch (username) &#123; case \"test\": dbUser = new User(1, \"test\", \"47ec2dd791e31e2ef2076caf64ed9b3d\", false, new String[]&#123;\"user\"&#125;); break; case \"admin\": dbUser = new User(2, \"admin\", \"a66abb5684c45962d887564f08346e8d\", false, new String[]&#123;\"admin\",\"user\"&#125;); break; case \"tourist\": dbUser = new User(3, \"tourist\", \"33d2ebfc6787cdb030d04dc940f8f4ed\", true, new String[]&#123;\"tourist\"&#125;); break; default: break; &#125; return dbUser; &#125;&#125; 枚举类AlgorithmEnum.java，代码如下： 1234567891011121314151617181920212223242526public enum AlgorithmEnum &#123; MD5(\"MD5\", \"MD5加密算法\"), SHA1(\"SHA1\", \"SHA1加密算法\"); private String value; private String info; AlgorithmEnum(String value, String info) &#123; this.value = value; this.info = info; &#125; /** * 值 * @return */ public String value() &#123; return this.value; &#125; /** * 值说明 * @return */ public String info() &#123; return this.info(); &#125;&#125; CryptUtils.java代码，改工具类主要用于在配置好shiro后，对于测试数据进行加密以便于在shiroRealm进行密码匹配后能够正常执行，同时后期需要做的用户注册后用户密码加密存储在数据库中也是一个重要的步骤。 1234567891011121314151617181920212223242526package site.sixteen.demo.util;import lombok.extern.slf4j.Slf4j;import org.apache.shiro.crypto.hash.SimpleHash;import org.apache.shiro.util.ByteSource;import site.sixteen.demo.enums.AlgorithmEnum;@Slf4jpublic class CryptUtils &#123; public static String encrypt(String saltStr, String toBeEncryptStr, String hashAlgorithmName, int hashIterations) &#123; Object credentials = toBeEncryptStr; Object salt = ByteSource.Util.bytes(saltStr); Object result = new SimpleHash(hashAlgorithmName, credentials, salt, hashIterations); return String.valueOf(result); &#125; public static void main(String[] args) &#123; String saltStr = \"tourist\"; String toBeEncryptStr = \"123456\"; int hashIterations = 1; log.info(\"&#123;&#125;:&#123;&#125;\", saltStr, toBeEncryptStr); log.info(\"&#123;&#125;\", CryptUtils.encrypt(saltStr, toBeEncryptStr, AlgorithmEnum.MD5.value(), hashIterations)); &#125;&#125; UserLoginException.java用户登录异常处理类 123456789101112import lombok.Getter;@Getterpublic class UserLoginException extends Exception &#123; private String message; public UserLoginException(String message) &#123; this.message = message; &#125;&#125; 创建一个全局异常处理类AppExceptionHandler.java 12345678910111213141516171819import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.mvc.support.RedirectAttributes;/** * @author panhainan@yeah.net(@link http://sixteen.site) **/@Slf4j@ControllerAdvicepublic class AppExceptionHandler &#123; @ExceptionHandler(UserLoginException.class) public String handleUserLoginException(Exception e, RedirectAttributes redirectAttributes) &#123; log.info(\"异常：&#123;&#125;\",e.getMessage()); redirectAttributes.addFlashAttribute(\"errorMsg\", e.getMessage()); return \"redirect:/login\"; &#125;&#125; 配置全局异常处理器需要在applicationContext.xml增加包扫描处理： 1&lt;context:component-scan base-package=\"site.sixteen.demo.exception\"/&gt; UserController.java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package site.sixteen.demo.web;import lombok.extern.slf4j.Slf4j;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import site.sixteen.demo.entity.User;import site.sixteen.demo.exception.UserLoginException;@Slf4j@Controllerpublic class UserController &#123; @GetMapping(&#123;\"/\",\"/index\"&#125;) public String index()&#123; return \"index\"; &#125; @GetMapping(\"/unauthorized\") public String unauthorized()&#123; return \"unauthorized\"; &#125; @GetMapping(\"/login\") public String login() &#123; return \"login\"; &#125; @PostMapping(\"/login\") public String login(User user) throws UserLoginException &#123; Subject currentSubject = SecurityUtils.getSubject(); if (!currentSubject.isAuthenticated()) &#123; UsernamePasswordToken upToken = new UsernamePasswordToken(user.getUsername(), user.getPassword()); try &#123; // 执行登录. currentSubject.login(upToken); &#125; catch (UnknownAccountException e) &#123; // 若没有指定的账户, 则 shiro 将会抛出 UnknownAccountException 异常. //一般建议提示用户名密码错误 throw new UserLoginException(\"用户不存在！\"); &#125; catch (IncorrectCredentialsException e) &#123; // 若账户存在, 但密码不匹配, 则 shiro 会抛出 IncorrectCredentialsException 异常。 //一般建议提示用户名密码错误 throw new UserLoginException(\"用户密码错误！\"); &#125; catch (LockedAccountException e) &#123; // 用户被锁定的异常 LockedAccountException throw new UserLoginException(\"用户已被锁定！\"); &#125; catch (AuthenticationException e) &#123; // 所有认证时异常的父类. throw new UserLoginException(e.getLocalizedMessage()); &#125; &#125; return \"redirect:/index\"; &#125;&#125; login.jsp 123456789101112131415&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Login&lt;/h1&gt;&lt;form action=\"/login\" method=\"post\"&gt; Username:&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;&lt;br&gt; Password:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; $&#123;errorMsg&#125;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 到此一个简单的登录认证已经实现。效果如下： 接下来实现授权代码的编写。 8. 实现授权Authorization操作授权操作主要是实现doGetAuthorizationInfo方法，主要有一下步骤： 从PrincipalCollection中来获取登录用户的信息 利用登录的用户信息获取当前用户的角色或权限（可能需要查询数据库） 创建SimpleAuthorizationInfo，并设置roles属性 返回SimpleAuthorization对象 代码如下： 12345678910111213141516171819/** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; log.info(\"授权中：&#123;&#125;\", principals.getPrimaryPrincipal()); // 1. 从PrincipalCollection中来获取登录用户的信息 String username = String.valueOf(principals.getPrimaryPrincipal()); // 2. 利用登录的用户信息获取当前用户的角色或权限（可能需要查询数据库） User DbUser = UserDAO.fetchDataFromDB(username); // 3. 创建SimpleAuthorizationInfo，并设置roles属性 Set&lt;String&gt; roles = new HashSet&lt;&gt;(); for (String roleStr : DbUser.getRoles()) &#123; roles.add(roleStr); &#125; SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(roles); // 4. 返回SimpleAuthorization对象 return simpleAuthorizationInfo; &#125; 9. 实现授权的相关类及jsp页面shiro标签设置index.jsp 1234567891011121314151617181920212223&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;欢迎您，&lt;shiro:user&gt; &lt;shiro:principal/&gt;&lt;/shiro:user&gt;&lt;ul&gt; &lt;shiro:hasRole name=\"user\"&gt; &lt;li&gt;&lt;a href=\"/user\"&gt;用户信息界面&lt;/a&gt;&lt;/li&gt; &lt;/shiro:hasRole&gt; &lt;shiro:hasRole name=\"admin\"&gt; &lt;li&gt;&lt;a href=\"/manage\"&gt;管理界面&lt;/a&gt;&lt;/li&gt; &lt;/shiro:hasRole&gt; &lt;li&gt;&lt;a style=\"color: red\" href=\"/logout\"&gt;退出&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; user.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;user界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;user&#125;&lt;/body&gt;&lt;/html&gt; manage.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;管理页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 您好，管理员！&lt;/body&gt;&lt;/html&gt; unauthorized.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;失败...&lt;/title&gt;&lt;/head&gt;&lt;body&gt;没有访问权限！&lt;/body&gt;&lt;/html&gt; 结果展示 再次重复代码地址：https://github.com/panhainan/spring-mvc-shiro-demo 因为目前留言插件审核问题无法使用，有疑问的可以联系我的QQ 1016593477或者我的邮箱在我的网站介绍里面可以找到。谢谢！","categories":[{"name":"Shiro","slug":"Shiro","permalink":"http://panhainan.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://panhainan.github.io/tags/Shiro/"}]},{"title":"快速搭建Spring MVC Web项目","slug":"快速搭建Spring-MVC-Web项目","date":"2018-08-09T14:50:00.000Z","updated":"2019-09-30T18:49:29.806Z","comments":true,"path":"2018/08/09/快速搭建Spring-MVC-Web项目/","link":"","permalink":"http://panhainan.github.io/2018/08/09/快速搭建Spring-MVC-Web项目/","excerpt":"此篇笔记主要讲述快速搭建一个简易Spring MVC Web项目的相关配置。主要有创建Maven webapp项目，配置pom.xml中的jar引入，配置web.xml以及dispatcher-servlet.xml等文件。","text":"此篇笔记主要讲述快速搭建一个简易Spring MVC Web项目的相关配置。主要有创建Maven webapp项目，配置pom.xml中的jar引入，配置web.xml以及dispatcher-servlet.xml等文件。 创建Maven webapp项目 配置pom.xml 配置web.xml 配置dispatcher-servlet.xml 按需配置applicationContext.xml 首先，新建一个Maven web app项目，项目结构如下： 然后配置pom.xml，按需配置，主要是spring-webmvc.jar和javax.servlet-api.jar 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;site.sixteen&lt;/groupId&gt; &lt;artifactId&gt;spring-mvc-shiro-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-mvc-shiro-demo Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.6.RELEASE&lt;/spring.version&gt; &lt;servletapi.version&gt;3.1.0&lt;/servletapi.version&gt; &lt;logback.version&gt;1.1.2&lt;/logback.version&gt; &lt;jcl.slf4j.version&gt;1.7.12&lt;/jcl.slf4j.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springmvc支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--servlet支持--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servletapi.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--以上是spring mvc项目必备基础jar包--&gt; &lt;!--junit测试支持--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring测试支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;$&#123;jcl.slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- getter/setter/log等快速使用注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--工具类支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 用于处理日期数据，需要@DateTimeFormat的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据校验 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-mvc-shiro-demo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 配置web.xml文件，主要配置项如下： 修改web-app版本号，注意不同版本号对应的头部信息（点击查看 ） 配置Spring容器的配置文件 配置上下文监听器 配置前端控制器 配置静态资源处理方式 配置字符过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\" metadata-complete=\"true\"&gt; &lt;display-name&gt;Spring MVC Web Application with Shiro&lt;/display-name&gt; &lt;!--配置加载Spring容器配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置上下文监听器ContextLoaderListener--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置SpringMVC前端控制器DispatcherServlet（Spring子容器） --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;!-- 配置过滤所有请求，符合SpringMVC对Restful的支持 / 表示拦截除jsp外的所有请求 /* 表示拦截所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 以上是spring mvc项目基础配置 --&gt; &lt;!--配置静态资源默认处理方式，需要在spring-mvc.xml里面配置&lt;mvc:default-servlet-handler/&gt;--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;url-pattern&gt;/images/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置数据传输编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 配置前端控制器dispatcher-servlet.xml，有时可能命名为spring-mvc.xml，根据个人习惯或者公司规定。 开启注解模式 配置包扫描 配置静态资源处理方式 配置视图解析器 配置拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启SpringMVC注解模式--&gt; &lt;!-- 简化配置： （1）自动注册DefaultAnnotationHandlerMapping，AnnotationMethodHandlerAdapter （2）提供一系列：数据绑定，数字和日期的format @NumberFormat，@DataTimeFormat， xml,JSON默认读写支持 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置web相关Bean的扫描路径 --&gt; &lt;context:component-scan base-package=\"site.sixteen.demo.web\"/&gt; &lt;!-- 配置静态资源默认处理方式 需要在web.xml中增加对静态资源的处理 --&gt; &lt;!-- servlet-mapping 映射路径：\"/\" --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置Jsp视图解析器ViewResolver--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" &gt; &lt;property name=\"prefix\" value=\"/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- MVC拦截器，根据需要配置 应用场景：用户登录权限 --&gt; &lt;!-- 规则： 1. /**拦截多级，如/test/hello 2. /*拦截一级，如/test，不会拦截/test/**请求 --&gt; &lt;!-- &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"site.sixteen.demo.interceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; --&gt;&lt;/beans&gt; 配置Spring容器的配置文件，这里采用默认的文件命名 applicationContext.xml（因为一般可能还会细分为service，dao等配置） 1略，这里只考虑搭建Spring MVC项目，暂时不考虑服务器端的具体实现 到此，一个简单的Spring MVC Web项目搭建完毕。 运行结果如下，","categories":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://panhainan.github.io/categories/Spring-MVC/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://panhainan.github.io/tags/Spring-MVC/"}]},{"title":"Servlet的web.xml对应常用版本号的头部信息","slug":"Servlet的web.xml对应常用版本号的头部信息","date":"2018-08-09T14:46:00.000Z","updated":"2019-09-30T18:49:29.799Z","comments":true,"path":"2018/08/09/Servlet的web.xml对应常用版本号的头部信息/","link":"","permalink":"http://panhainan.github.io/2018/08/09/Servlet的web.xml对应常用版本号的头部信息/","excerpt":"这篇笔记提供Servlet目前常用的2.5，3.0以及3.1版本对应的web.xml的头部信息。","text":"这篇笔记提供Servlet目前常用的2.5，3.0以及3.1版本对应的web.xml的头部信息。 Servlet 2.5 deployment descriptor Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;/web-app&gt; Servlet 3.0 deployment descriptor Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaee 1234567&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt;&lt;/web-app&gt; Servlet 3.1 deployment descriptor Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt;&lt;/web-app&gt; ###","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://panhainan.github.io/categories/Servlet/"}],"tags":[{"name":"web.xml版本号","slug":"web-xml版本号","permalink":"http://panhainan.github.io/tags/web-xml版本号/"}]},{"title":"SpringBoot学习笔记-出自尚硅谷","slug":"SpringBoot学习笔记-出自尚硅谷","date":"2018-04-15T16:10:41.000Z","updated":"2019-09-30T18:49:29.807Z","comments":true,"path":"2018/04/16/SpringBoot学习笔记-出自尚硅谷/","link":"","permalink":"http://panhainan.github.io/2018/04/16/SpringBoot学习笔记-出自尚硅谷/","excerpt":"","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 123456789 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAutoConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页12345678910111213141516171819202122232425//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 123456789101112131415161718192021222324252627282930/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(\"SpringApplicationRunListener...starting...\"); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(\"SpringApplicationRunListener...finished...\"); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(\"ApplicationRunner...run....\"); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://panhainan.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://panhainan.github.io/tags/SpringBoot/"}]},{"title":"SpringMVC数据校验","slug":"SpringMVC数据校验","date":"2018-04-09T07:17:52.000Z","updated":"2019-09-30T18:49:29.801Z","comments":true,"path":"2018/04/09/SpringMVC数据校验/","link":"","permalink":"http://panhainan.github.io/2018/04/09/SpringMVC数据校验/","excerpt":"SpringMVC使用验证框架 Bean Validation提供了对于数据的校验功能，添加 validation-api 和hibernate-validator依赖，即可对于前台传递的数据进行校验。","text":"SpringMVC使用验证框架 Bean Validation提供了对于数据的校验功能，添加 validation-api 和hibernate-validator依赖，即可对于前台传递的数据进行校验。 一、添加依赖 1234567891011&lt;!--数据校验--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt; 二、对实体进行注解标志验证类型123456789101112131415161718192021222324import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;import javax.validation.constraints.Size;import java.util.Date;/** * 身份证 */public class Card &#123; @Size(min = 2,max = 10,message = \"长度介于2-10个字符之间\") private String name; @Pattern(regexp = \"^[1-9][0-9]&#123;5&#125;(19|20)[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|31)|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;([0-9]|x|X)$\",message = \"该身份证号无效\") private String number; @NotNull(message =\"&#123;expiringDate.notnull&#125;\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date expiringDate; 省略构造方法和 get set 方法 ...&#125; 这里的@DateTimeFormat注解用于处理日期类型数据传递，与本文的数据校验没有关系，请查看此文：SpringMVC数据绑定（Date类型） 对面上面@Size注解中的message属性，还可以通过类似于@NotNull注解中的配置方法来统一配置，采用{expiringDate.notnull}方法获取，需要在classpath路径下添加一个 ValidationMessages.properties（或者ValidationMessages_zh_CN.properties） 文件，在里面以键值对的格式配置，如下：1expiringDate.notnull=失效日期不能为空 三、Controller层处理代码如下：123456789@RequestMapping(value = \"/addCard\", method = RequestMethod.POST)public String addCard(@Valid Card card, Errors errors, Model model) &#123; log.info(\"&#123;&#125;\", card); if (errors.hasErrors()) &#123; return \"addCard\"; &#125; model.addAttribute(\"card\", card); return \"addCardSuccess\";&#125; 注意@Valid Card card, Errors errors，对需要校验的实体需要增加@Valid注解，同时Errors类需要紧跟需要验证的实体后面。可以自行获取errors对象内部的相关信息，有兴趣的可以自行看看它的源码以及调用它的方法打印一下数据看看。 四、编写测试页面这里采用了spring的标签，建议去了解一下，很实用。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加身份证信息&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&lt;c:url value=\"/\"/&gt;/css/bootstrap.min.css\"&gt; &lt;style&gt; .has-error&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;sf:form commandName=\"card\" cssClass=\"form-horizontal\" cssStyle=\"width: 600px;margin: 0 auto\" method=\"post\"&gt; &lt;h1 class=\"col-sm-offset-2\"&gt;添加身份证信息&lt;/h1&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\" &gt;姓 名：&lt;/label&gt; &lt;div class=\"col-sm-6\" &gt;&lt;sf:input path=\"name\" cssClass=\"form-control\" /&gt;&lt;/div&gt; &lt;div class=\"col-sm-4 has-error\"&gt;&lt;sf:errors path=\"name\"/&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\" &gt;身份证号：&lt;/label&gt; &lt;div class=\"col-sm-6\"&gt;&lt;sf:input path=\"number\" class=\"form-control\"/&gt;&lt;/div&gt; &lt;div class=\"col-sm-4 has-error\"&gt;&lt;sf:errors path=\"number\"/&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\" &gt;失效日期：&lt;/label&gt; &lt;div class=\"col-sm-6\"&gt;&lt;sf:input path=\"expiringDate\" class=\"form-control\" type=\"date\"/&gt;&lt;/div&gt; &lt;div class=\"col-sm-4 has-error\"&gt;&lt;sf:errors path=\"expiringDate\"/&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-5\"&gt; &lt;input type=\"submit\" class=\"btn btn-success btn-block\" value=\"点击添加\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/sf:form&gt;&lt;/body&gt;&lt;/html&gt; 五、测试效果 六、源码提供前往 GitHub：github.com/panhainan/spring-family 下面提供内置的验证约束注解如下表所示（摘自hibernate validator reference）: 验证注解 验证的数据类型 说明 @AssertFalse Boolean,boolean 验证注解的元素值是false @AssertTrue Boolean,boolean 验证注解的元素值是true @NotNull 任意类型 验证注解的元素值不是null @Null 任意类型 验证注解的元素值是null @MIN(value=值) BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型 验证注解的元素值大于等于@Min指定的value值 @MAX(value=值) 和@Min要求一样 验证注解的元素值小于等于@Max指定的value值 @DecimalMin(value=值) 和@Min要求一样 验证注解的元素值大于等于@ DecimalMin指定的value值 @DecimalMax(value=值) 和@Min要求一样 验证注解的元素值小于等于@ DecimalMax指定的value值 @Digits(integer=整数位数, fraction=小数位数) 和@Min要求一样 验证注解的元素值的整数位数和小数位数上限 @Size(min=下限, max=上限) 字符串、Collection、Map、数组等 验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小 @Past java.util.Date,java.util.Calendar;Joda Time类库的日期类型 验证注解的元素值（日期类型）比当前时间早 @Future 与@Past要求一样 验证注解的元素值（日期类型）比当前时间晚 @NotBlank CharSequence子类型 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的首位空格 @Length(min=下限, max=上限) CharSequence子类型 验证注解的元素值长度在min和max区间内 @NotEmpty CharSequence子类型、Collection、Map、数组 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @Range(min=最小值, max=最大值) BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型 验证注解的元素值在最小值和最大值之间 @Email(regexp=正则表达式,flag=标志的模式) CharSequence子类型（如String） 验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式 @Pattern(regexp=正则表达式,flag=标志的模式) String，任何CharSequence的子类型 验证注解的元素值与指定的正则表达式匹配 @Valid 任何非原子类型 指定递归验证关联的对象；如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/tags/SpringMVC/"},{"name":"数据校验","slug":"数据校验","permalink":"http://panhainan.github.io/tags/数据校验/"}]},{"title":"SpringMVC4文件上传实例","slug":"SpringMVC4文件上传实例","date":"2018-04-04T06:15:37.000Z","updated":"2019-09-30T18:49:29.799Z","comments":true,"path":"2018/04/04/SpringMVC4文件上传实例/","link":"","permalink":"http://panhainan.github.io/2018/04/04/SpringMVC4文件上传实例/","excerpt":"简单来说，本文介绍了如何在SpringMVC Web应用中处理文件上传，同时也介绍了如何处理比较常见的文件大小超出限制异常。","text":"简单来说，本文介绍了如何在SpringMVC Web应用中处理文件上传，同时也介绍了如何处理比较常见的文件大小超出限制异常。 Spring使用MultipartResolver接口来处理文件上传到Web应用服务器，这个接口有两种实现方式： StandardServletMultipartResolver – Servlet 3.0 multipart request parsing. CommonsMultipartResolver – Classic commons-fileupload.jar 本文主要介绍第一种方式：Servlet 3.0 multipart request parsing. 这里就没有重复造轮子了，可以直接看看传送门给的链接，这个作者写的比较详细， 传送门：https://www.mkyong.com/spring-mvc/spring-mvc-file-upload-example/ 可以直接参照这篇文章进行，对于一些问题在这个作者的博客中也可以找到。这个作者博客里面还有很多其他的例子，可以学习学习。 同时附上我写的文件上传的代码链接：https://github.com/panhainan/spring-family/springmvc-annotation-fileupload","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/tags/SpringMVC/"},{"name":"FileUpload","slug":"FileUpload","permalink":"http://panhainan.github.io/tags/FileUpload/"}]},{"title":"SpringMVC数据绑定（Date类型）","slug":"SpringMVC数据绑定-Date类型","date":"2018-04-01T16:23:47.000Z","updated":"2019-09-30T18:49:29.803Z","comments":true,"path":"2018/04/02/SpringMVC数据绑定-Date类型/","link":"","permalink":"http://panhainan.github.io/2018/04/02/SpringMVC数据绑定-Date类型/","excerpt":"SpringMVC对于Date类型的参数的处理方式有个专门的注解@DateTimeFormat,引入这个注解需要增加一个jar依赖。","text":"SpringMVC对于Date类型的参数的处理方式有个专门的注解@DateTimeFormat,引入这个注解需要增加一个jar依赖。123456&lt;!-- 用于处理@DateTimeFormat的支持jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 在maven中引入该依赖后，可以直接在需要传输的参数前面加上@DateTimeFormat即可，如： 12345678910111213/** * Date格式 * get方式：http://localhost:8080/springmvc/dateType?date=2014-10-10 * post方式：http://localhost:8080/springmvc/dateType 附带参数：date=2014-10-10 * @param date * @return */@RequestMapping(\"/dateType\")@ResponseBodypublic String dateType(@DateTimeFormat(pattern = \"yyyy-MM-dd\") Date date)&#123; log.info(\"&#123;&#125;\",date.toString()); return date.toString();&#125; 如果是包含日期Date的实体，在其内部的日期变量处加上@DateTimeFormat(pattern = “yyyy-MM-dd”)即可，pattern对面的值即是要传入的日期的格式。 测试直接按照贴的注释进行即可。 参考链接： springMvc–接受日期类型参数处理 - liuconglin - 博客园https://www.cnblogs.com/liuconglin/p/5777879.html SpringMVC处理Date类型的成员变量方法 - CSDN博客https://blog.csdn.net/z69183787/article/details/40373565","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/tags/SpringMVC/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://panhainan.github.io/tags/数据绑定/"},{"name":"日期数据绑定","slug":"日期数据绑定","permalink":"http://panhainan.github.io/tags/日期数据绑定/"}]},{"title":"SpringMVC拦截器及静态资源处理方法","slug":"SpringMVC拦截器及静态资源处理方法","date":"2018-03-30T08:23:29.000Z","updated":"2019-09-30T18:49:29.801Z","comments":true,"path":"2018/03/30/SpringMVC拦截器及静态资源处理方法/","link":"","permalink":"http://panhainan.github.io/2018/03/30/SpringMVC拦截器及静态资源处理方法/","excerpt":"本文讲解一下SpringMVC拦截器的工作原理、如何使用以及针对静态资源放行的三种处理方法的相关问题。","text":"本文讲解一下SpringMVC拦截器的工作原理、如何使用以及针对静态资源放行的三种处理方法的相关问题。 拦截器简介 拦截器是指通过统一拦截从浏览器（或其他应用）发往服务器的请求来完成功能的增强。 使用场景：解决请求的共性问题（如：乱码问题、权限验证问题） 介绍拦截器的基本工作原理之前，先介绍一个例子：SpringMVC配置过滤器来解决乱码问题 这个问题相信大家很熟悉，解决方法也是很简单，就是在web.xml里面配置一个filter，如下：1234567891011121314151617&lt;!-- encoding --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 进行如此配置，就解决了请求传中文参数乱码问题了。而SpringMVC的拦截器和过滤器非常相似。 拦截器的实现 实现HandlerInterceptor接口(还有实现WebRequestInterceptor接口，不过不建议)，会默认要求实现3个方法，根据需求进行设计;如： 123456789101112131415161718192021222324252627282930313233343536373839404142/*此处还有可以实现WebRequestInterceptor接口，不过其实现的preHandle方法没有返回值，也就是不能终止请求，其注册配置方法也是一样*/@Slf4jpublic class TestInterceptor implements HandlerInterceptor&#123; /** * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用， * SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor， * 然后SpringMVC会根据声明的前后顺序一个接一个的执行， * 而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。 * SpringMVC的这种Interceptor链式结构也是可以进行中断的， * 这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。 * 参数Object表示被拦截的请求的目标对象 */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; log.debug(\"执行到preHandle方法\"); return true; &#125; /** * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。 * postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 后， 也就是在Controller的方法调用之后执行， * 但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。 * 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用， * 这跟Struts2里面的拦截器的执行过程有点像， * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法， * Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action， * 然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; log.debug(\"执行到postHandle方法\"); &#125; /** * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。 * 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的， */ @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; log.debug(\"执行到afterCompletion方法\"); &#125;&#125; 在SpringMVC配置中注册; 配置拦截规则，根据需求进行设计。 2,3步的实现如下：12345678910&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 规则： 1. /**拦截多级，如/test/hello 2. /*拦截一级，如/test，不会拦截/test/**请求 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.panhainan.interceptor.TestInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器和过滤器的区别过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大；拦截器Interceptor依赖于框架容器，基于反射容器，只过滤请求。 SpringMVC针对静态资源如js，css等文件的三种处理方式：方法一：使用 mvc:resources123456789101112131415161718&lt;mvc:resources location=\"/\" mapping=\"/**/*.js\"/&gt; &lt;mvc:resources location=\"/\" mapping=\"/**/*.css\"/&gt; &lt;mvc:resources location=\"/assets/\" mapping=\"/assets/**/*\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/*\" cache-period=\"360000\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/fonts/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.css\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.js\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.png\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.gif\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpeg\"/&gt; &lt;bean class=\"com.panhainan.interceptor.TestInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 方法二：使用默认的静态资源处理Servlet处理静态资源 在spring-mvc.xml中启用默认Servlet1&lt;mvc:default-servlet-handler/&gt; 在web.xml中增加对静态资源的处理，但是当前的设置必须在Spring的Dispatcher的前面1234567&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;url-pattern&gt;/assets/*\"&lt;/url-pattern&gt; &lt;url-pattern&gt;/images/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 方法三：修改Spring的全局拦截设置为*.do的拦截1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 三种方案的优劣分析 第一种方案配置比较臃肿，多个拦截器时增加文件行数，不推荐使用； 第二种方案使用默认的Servlet进行资源文件的访问，Spring拦截所有请求，然后再将资源文件交由默认的Servlet进行处理，性能上少有损耗； 第三种方案Spring只是处理以”.do”结尾的访问，性能上更加高效，但是再访问路径上必须都以“.do”结尾，URL不太文雅。综上所述，推荐使用第二和第三种方案 参考文章SpringMVC 拦截器不拦截静态资源的三种处理方式 SpringMVC之mvc:interceptors拦截器的用法 本文的代码可以在github上找到，地址为：github.com/panhainan/spring-family","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC拦截器","slug":"SpringMVC拦截器","permalink":"http://panhainan.github.io/tags/SpringMVC拦截器/"}]},{"title":"版本管理工具Git快速掌握推荐阅读","slug":"版本管理工具Git快速掌握推荐阅读","date":"2018-03-29T15:12:53.000Z","updated":"2019-09-30T18:49:29.806Z","comments":true,"path":"2018/03/29/版本管理工具Git快速掌握推荐阅读/","link":"","permalink":"http://panhainan.github.io/2018/03/29/版本管理工具Git快速掌握推荐阅读/","excerpt":"以前也用过Git，只不过一直停留在一个人使用，对于它的很多特性看了也没怎么用，今天又重温了一下，感觉不错。","text":"以前也用过Git，只不过一直停留在一个人使用，对于它的很多特性看了也没怎么用，今天又重温了一下，感觉不错。 这类的文章太多了，自己也就不打算写了，这里推荐一本书《Pro Git》，给个网页版地址：http://git.oschina.net/progit/ 也推荐一下廖雪峰的Git教程，读者自行百度，算是比较有名的。 同时这里还有几篇博客对于git提交log的写法的介绍 伯乐在线：写好 Git Commit 信息的 7 个建议 阮一峰的网络日志：Commit message 和 Change log 编写指南","categories":[{"name":"Git","slug":"Git","permalink":"http://panhainan.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://panhainan.github.io/tags/Git/"},{"name":"版本管理工具","slug":"版本管理工具","permalink":"http://panhainan.github.io/tags/版本管理工具/"}]},{"title":"Java异常的抓抛选取和自定义异常","slug":"Java异常的抓抛选取和自定义异常","date":"2018-03-22T16:54:30.000Z","updated":"2019-09-30T18:49:29.796Z","comments":true,"path":"2018/03/23/Java异常的抓抛选取和自定义异常/","link":"","permalink":"http://panhainan.github.io/2018/03/23/Java异常的抓抛选取和自定义异常/","excerpt":"Java异常这是个很常用的东西，对于它的分类和处理方式我们来学习一番，特别是他的处理方式（捕获和抛出）的应用以及应用场景很重要，需要好好理解。","text":"Java异常这是个很常用的东西，对于它的分类和处理方式我们来学习一番，特别是他的处理方式（捕获和抛出）的应用以及应用场景很重要，需要好好理解。 内容大纲 什么是异常 异常的分类 异常的处理(重点) 自定义异常 什么是异常 在Java中，异常是指程序在运行出错时创建的一种特殊的运行时错误对象，并定义一个基类java.lang.Throwable作为所有异常的超类。 异常的分类 在Java API中已经定义了许多异常类（称之为预定义异常），这些类如下图， Throwable下分为Error和Exception， 1. Error是指不能通过程序的代码解决或者指程序自身解决不了的错误，其描述了Java运行时系统的内部错误和资源耗尽错误； 2. Exception是指可以通过程序的代码进行捕获来处理或者指可以通过程序自身解决的异常。 在Exception中又分为两类：RuntimeException和其他异常， 1. 由程序错误导致的异常属于RuntimeException； 2. 程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。 一条相当有道理的规则：如果出现RuntimeException异常，那么一定是你的问题。 Java语言规范将派生于Error类和RuntimeException类的所有异常称之为未检查异常（unchecked exception），所有其他的异常称之为已检查异常（checked exception）。而Java编译器要求必须对所有已检查异常提供异常处理，否则会出现编译错误。 注意：RuntimeException这个名字容易让人混淆，实际上，所有的错误都发生在运行时。————Java核心技术 卷一 下面举一个例子，我们通过这个例子来学习异常的处理方式以及异常抓抛的应用场景。这里我们的例子可以模拟成一个web项目，client表示处理用户请求的控制器层，service为业务层，dao为数据持久层，结构如下图， 代码如下：123456789public class UserDAO &#123; public Date strToDate(String str) throws ParseException &#123; Date date = null; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); date = simpleDateFormat.parse(str); return date; &#125;&#125; 1234567public class UserService &#123; public Date strToDate(String string) throws ParseException &#123; UserDAO userDAO=new UserDAO(); return userDAO.strToDate(string); &#125;&#125; 1234567891011121314151617public class UserClient &#123; private static Logger logger = Logger.getLogger(\"UserClient\"); public static void main(String[] args) &#123;// String str = \"2018-03-23 00:30:16\"; String str = \"201803-323 00:30:16\"; UserService userService = new UserService(); Date date =null; try &#123; date = userService.strToDate(str); &#125; catch (ParseException e) &#123;// e.printStackTrace(); logger.info(e.getMessage()+\"(字符串格式错误，无法解析!)\"); &#125;finally &#123; logger.info(str+\"-&gt;\"+date); &#125; &#125;&#125; 上述的代码就表示一个用户请求服务器进行特定格式字符串转化成日期的API。 异常的处理 我们看UserDAO，可以看到如果去掉throws ParseException，此时simpleDateFormat.parse(str)这里就会出现编译错误，这就是前面所说的已检查异常，程序必须为其提供异常处理方式。 异常的处理方式有两种，抓（即采用try catch finally）或者抛（即throws exception）。而UserDAO这里我们为何采用抛？并且在UserService也采用来抛，而在UserClient处又为何采用了抓？ 解答：我们是这么约定的，将异常在最初发起此请求的地方进行抓取，并对其处理，而在其他地方对其往上抛出，不进行处理。因为只有发起此请求的地方知道怎么应对出现的异常进行处理。 举个例子，小明去银行取一个亿，银行的前台需要向上级经理请示，经理通知金库看守员取一个亿现金，看守员一看金库发现没有一个亿现金，于是这里就出问题了，小明要取十个亿，但是金库没有十个亿，这怎么办，金库看守员解决不了这个问题，就汇报给经理，金库目前没有这么多现金，这里就相当于DAO层将异常抛出给Service层，因为他解决不了这个问题，经理一看，他也搞不定啊，这一下子从哪掏出这么多钱，他就把这个问题丢给了前台，前台接到这个问题后，没办法，他得解决，他不可能把这个问题丢给小明，那样这个银行就不用开了，于是前台就去想办法，怎么解决呢，他发现以前也有这种情况，处理方式就是告诉小明，金库对于一下取一百万现金有个规定，就是先要预约，不然资金周转没有那么快，于是乎小明收到这个通知后就知道了，要预约。 这个例子就完了，可能会有疑问，说经理也可以解决这个问题啊，直接告诉小明，让小明通知顾客要预约，这样不就是Service层也可以捕获这个异常了吗？这里呢我也是有点疑惑，如果你有好的解决办法请联系我，一起探讨。 上面这个出现的是已检查异常，必须对其进行异常处理，这里还举个未检查异常，就是经常说的除零运算，代码如下：123public int divide(int a ,int b)&#123; return a/b;&#125; 这个方法是可能会出现除数为零的异常的（java.lang.ArithmeticException: / by zero），但是他是RuntimeException的子类，属于未检查异常，即不必须对其进行异常处理。不过这种问题作为程序员也是必须要解决的，因为“如果出现RuntimeException异常，那么一定是你的问题。” 自定义异常 我们先来看一个例子，假设我们现在有个程序，要录入学生的姓名和年龄学生姓名已经录入成功，年龄等待我们录入，不过有些要求，年龄的输入限制范围是0~150，如果不在这个范围则需要重新录入。 学生实体类代码如下：1234567891011121314151617181920212223public class Student &#123; private String name; private int age; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 学生信息录入代码如下：12345678910public static void main(String[] args) &#123; Student student = new Student(); Scanner scanner = new Scanner(System.in); String name = \"十六子\"; student.setName(name); System.out.println(\"请输入年龄：\"); int age = scanner.nextInt(); student.setAge(age); System.out.println(student.toString());&#125; 我们现在需要将年龄录入这个地方修改以满足需求。 你可能这样操作，在int age = scanner.nextInt();后面加入以下代码：1234while(age&gt;150 || age&lt;0)&#123; System.out.println(\"请重新输入年龄：\"); age = scanner.nextInt();&#125; 或者说在setAge方法中进行if判断等。 但是，仔细想以下，这样的扩展性好不好，如果其他地方也要录入了呢，是不是又要这样操作一次，而如果编码人员没有注意到忘记了呢。 有没有更好的方法？ 那就是我们采用Java自定义异常来进行。 我们定义一个AgeException类，代码如下：123456789/** * 年龄异常类，用于判断录入年龄是否符合要求 */public class AgeException extends Exception &#123; public AgeException(String message) &#123; super(message); &#125;&#125; 然后修改setAge方法，1234567public void setAge(int age) throws AgeException &#123; if (age &lt; 0 || age &gt; 150) &#123; throw new AgeException(\"年龄不合法，请输入0~150之间的数字！\"); &#125; else &#123; this.age = age; &#125;&#125; 然后就会发现录入年龄setAge处会提示已检查异常编译错误，需要进行异常处理，因此我们采用try catch，修改后的录入代码为：123456789101112131415161718public static void main(String[] args) &#123; Student student = new Student(); Scanner scanner = new Scanner(System.in); String name = \"十六子\"; student.setName(name); while(true)&#123; System.out.println(\"请输入年龄：\"); int age = scanner.nextInt(); try &#123; student.setAge(age); break; &#125; catch (AgeException e) &#123;// e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125; System.out.println(student.toString());&#125; 对于异常的抓抛需要好好选取处理方式，同时在web应用中，我们也需要自定义一些异常来给予用户更好的体验。","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"Java异常","slug":"Java异常","permalink":"http://panhainan.github.io/tags/Java异常/"}]},{"title":"Java使用反射和自定义注解实现简单的ORM框架映射","slug":"Java使用反射和自定义注解实现简单的ORM框架映射","date":"2018-03-22T05:25:28.000Z","updated":"2019-09-30T18:49:29.797Z","comments":true,"path":"2018/03/22/Java使用反射和自定义注解实现简单的ORM框架映射/","link":"","permalink":"http://panhainan.github.io/2018/03/22/Java使用反射和自定义注解实现简单的ORM框架映射/","excerpt":"基于Java自定义注解、反射和JDBC的简单对象ORM映射框架，包含简单的CRUD和Page。这一篇文章基本上都是源码，静下心来看肯定会有收获的，有疑问或者有建议都可以通过邮箱或者QQ等方式连接作者，作者很乐意和你一起探讨。对于本文的代码，可以直接前往GitHub上获取，地址见文章末尾处。","text":"基于Java自定义注解、反射和JDBC的简单对象ORM映射框架，包含简单的CRUD和Page。这一篇文章基本上都是源码，静下心来看肯定会有收获的，有疑问或者有建议都可以通过邮箱或者QQ等方式连接作者，作者很乐意和你一起探讨。对于本文的代码，可以直接前往GitHub上获取，地址见文章末尾处。 首先定义三个注解@Table、@Id、@Column，分别用于表示数据库表、数据库表中的ID字段、数据库表中的其他字段。代码分别如下： 123456789import java.lang.annotation.*;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Table &#123; String value();&#125; 123456789import java.lang.annotation.*;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Id &#123; String value();&#125; 123456789import java.lang.annotation.*;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Column &#123; String value();&#125; 这里用到几年前写的一个DBUtil数据库连接工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.sql.*;import java.util.ResourceBundle;import java.util.logging.Level;import java.util.logging.Logger;/** * @author panhainan * @date 2015-4-8 * @TODO 数据库操作工具类 */public class DBUtil &#123; static ResourceBundle rbundle = ResourceBundle.getBundle(\"db\"); private static String driverName = rbundle.getString(\"driverClassName\"); private static String dbUser = rbundle.getString(\"username\"); private static String dbPass = rbundle.getString(\"password\"); private static String dbUrl = rbundle.getString(\"url\"); private static Logger logger = Logger.getLogger(\"com.panhainan.dborm.uitl.DBUtil\"); /** * @return Connection * @date 2015-4-8 * @TODO 获取数据库连接 */ public static Connection getConnection() &#123; logger.log(Level.INFO, \"Read source db.properties info ... \"); try &#123; logger.log(Level.INFO, \"Database connect start ...\"); // 这里使用这种方法已经指定了new出来的Driver是mysql的驱动 // DriverManager.registerDriver(new Driver()); Class.forName(driverName).newInstance(); Connection conn = null; conn = DriverManager.getConnection(dbUrl, dbUser, dbPass); if (conn != null) &#123; logger.log(Level.INFO, \"Database connect success : conn = \" + conn); return conn; &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, e.getMessage()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, e.getMessage()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, e.getMessage()); &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, e.getMessage()); &#125; logger.log(Level.CONFIG, \"Database connect failed !\"); return null; &#125; public static void closeConnection(Connection conn, PreparedStatement pstm, ResultSet rs) &#123; try &#123; // 捕捉异常 try &#123; if (rs != null) &#123; // 当ResultSet对象的实例rs不为空时 rs.close(); // 关闭ResultSet对象 logger.log(Level.INFO, \"Database rs closed .\"); &#125; &#125; finally &#123; try &#123; if (pstm != null) &#123; // 当Statement对象的实例stmt不为空时 pstm.close(); // 关闭Statement对象 logger.log(Level.INFO, \"Database pstm closed .\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (conn != null) &#123; // 当Connection对象的实例conn不为空时 conn.close(); // 关闭Connection对象 logger.log(Level.INFO, \"Database connect closed .\"); &#125; &#125; &#125; &#125; catch (Exception e) &#123; logger.log(Level.SEVERE, e.getMessage());// 输出异常信息 &#125; &#125; public static void main(String[] args) &#123; Connection conn = getConnection(); closeConnection(conn, null, null); &#125;&#125; 以及一个对数据库进行CRUD和Page的泛型工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276import com.panhainan.dborm.uitl.DBUtil;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.sql.*;import java.util.ArrayList;import java.util.List;import java.util.logging.Level;import java.util.logging.Logger;public class Repository&lt;T&gt; &#123; private Logger logger = Logger.getLogger(this.toString()); /** * @param insertSql * @return 插入的数据的id * @date 2015-4-9 * @TODO 执行插入语句 */ protected int executeInsert(String insertSql) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstm = null; ResultSet rs = null; int insertId = 0; try &#123; pstm = conn.prepareStatement(insertSql, PreparedStatement.RETURN_GENERATED_KEYS); pstm.executeUpdate(); rs = pstm.getGeneratedKeys(); while (rs.next()) &#123; insertId = rs.getInt(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; finally &#123; DBUtil.closeConnection(conn, pstm, rs); &#125; return insertId; &#125; /** * @param updateSql * @return 数据库受影响的行数 * @date 2015-4-9 * @TODO 执行更新语句或者删除语句 */ protected int executeUpdateAndDelete(String updateSql) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstm = null; int updateResult = 0; try &#123; pstm = conn.prepareStatement(updateSql); updateResult = pstm.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; finally &#123; DBUtil.closeConnection(conn, pstm, null); &#125; return updateResult; &#125; /** * @param sql * @param obj * @return T * @date 2015-4-10 * @TODO 通过数据库标识字段id查找 */ protected T executeGet(String sql, Class&lt;T&gt; obj) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstm = null; ResultSet rs = null; T o = null; try &#123; pstm = conn.prepareStatement(sql); rs = pstm.executeQuery(); o = obj.newInstance(); if (rs.next()) &#123; o = setTableToEntity(obj, rs); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; return o; &#125; /** * @param sql * @param c * @return List * @date 2015-4-10 * @TODO 根据参数params获取list */ protected List&lt;T&gt; executeList(String sql, Class&lt;T&gt; c) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstm = null; ResultSet rs = null; List&lt;T&gt; listObjects = null; T o = null; try &#123; pstm = conn.prepareStatement(sql); rs = pstm.executeQuery(); listObjects = new ArrayList&lt;T&gt;(); while (rs.next()) &#123; o = c.newInstance(); o = setTableToEntity(c, rs); listObjects.add(o); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; return listObjects; &#125; /** * @param sql * @param params * @return * @date 2015-4-11 * @TODO 获取总数 */ protected int getCountRow(String sql, Object... params) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstm = null; ResultSet rs = null; int countRow = 0; try &#123; pstm = conn.prepareStatement(sql); setParams(pstm, params); rs = pstm.executeQuery(); if (rs.next()) &#123; countRow = rs.getInt(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; return countRow; &#125; /** * @param c * @param rs * @return T * @date 2015-4-10 * @TODO 将数据库中查询出来的结果集ResultSet转化为实体 */ private T setTableToEntity(Class&lt;T&gt; c, ResultSet rs) &#123; T o = null; try &#123; o = c.newInstance(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); String[] columnName = new String[columnCount]; String[] columnClassName = new String[columnCount]; for (int i = 0; i &lt; columnCount; i++) &#123; columnName[i] = rsmd.getColumnName(i + 1); StringBuilder fieldName = new StringBuilder(columnName[i]); //当属性名包含下划线时，将下划线去掉，同时将下划线后面的第一个字母大写，形成驼峰命名法。 while (fieldName.toString().contains(\"_\")) &#123; int index = fieldName.indexOf(\"_\"); fieldName.replace(index, index + 2, String.valueOf(Character.toUpperCase(fieldName.charAt(index + 1)))); &#125; Class&lt;?&gt; paramType = c.getDeclaredField(fieldName.toString()).getType(); fieldName.setCharAt(0, Character.toUpperCase(fieldName.charAt(0))); String attributeSetName = \"set\" + fieldName.toString(); Method md = c.getMethod(attributeSetName, paramType); columnClassName[i] = rsmd.getColumnClassName(i + 1); if (\"java.lang.Integer\".equals(columnClassName[i])) &#123; Integer i1 = rs.getInt(columnName[i]); //数据库类型为int，可能对象类型为boolean，此时需要进行处理 if (\"boolean\".equalsIgnoreCase(paramType.toString())) &#123; if (i1 &gt; 0) md.invoke(o, true); else md.invoke(o, false); &#125; else &#123; md.invoke(o, i1); &#125; &#125; else if (\"java.lang.String\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getString(columnName[i])); &#125; else if (\"java.lang.Double\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getDouble(columnName[i])); &#125; else if (\"java.sql.Date\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getDate(columnName[i])); &#125; else if (\"java.lang.Boolean\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getBoolean(columnName[i])); &#125; else if (\"java.lang.Float\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getFloat(columnName[i])); &#125; else if (\"java.sql.Time\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getTime(columnName[i])); &#125; else if (\"java.sql.Timestamp\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getTimestamp(columnName[i])); &#125; else if (\"java.lang.Object\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getObject(columnName[i])); &#125; else if (\"java.math.BigDecimal\".equals(columnClassName[i])) &#123; md.invoke(o, rs.getBigDecimal(columnName[i])); &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (SecurityException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); logger.log(Level.SEVERE, \"**Error**:\" + e.getMessage()); &#125; return o; &#125; /** * @param pstm * @param params * @throws SQLException * @date 2015-4-9 * @TODO 设置SQL语句中的？参数 */ private void setParams(PreparedStatement pstm, Object[] params) throws SQLException &#123; if (params == null | params.length == 0) return; for (int i = 0; i &lt; params.length; i++) &#123; Object param = params[i]; if (param == null) &#123; pstm.setNull(i + 1, Types.NULL); &#125; else if (param instanceof Integer) &#123; pstm.setInt(i + 1, (Integer) param); &#125; else if (param instanceof Double) &#123; pstm.setDouble(i + 1, (Double) param); &#125; else if (param instanceof Long) &#123; pstm.setLong(i + 1, (Long) param); &#125; else if (param instanceof String) &#123; pstm.setString(i + 1, (String) param); &#125; else if (param instanceof Boolean) &#123; pstm.setBoolean(i + 1, (Boolean) param); &#125; else if (param instanceof java.util.Date) &#123; pstm.setTimestamp(i + 1, new java.sql.Timestamp(((java.util.Date) param).getTime())); &#125; &#125; &#125;&#125; 然后我们在这个泛型工具类的基础上实现一个CRUD和Page的对自定义注解解析的工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274import com.panhainan.dborm.annotation.Column;import com.panhainan.dborm.annotation.Id;import com.panhainan.dborm.annotation.Table;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.List;import java.util.logging.Logger;public class CrudRepository&lt;T&gt; extends Repository&lt;T&gt; &#123; private Logger logger = Logger.getLogger(this.toString()); public T get(int id, Class&lt;T&gt; t) &#123; T obj = null; StringBuilder sql = new StringBuilder(); try &#123; obj = t.newInstance(); Class c = obj.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return null; &#125; sql.append(\"select * from \") .append(((Table) c.getAnnotation(Table.class)).value()); Field[] fields = c.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(Id.class)) &#123; sql.append(\" where \") .append(field.getAnnotation(Id.class).value()) .append(\"=\") .append(id); break; &#125; &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; logger.info(sql.toString()); obj = super.executeGet(sql.toString(), t); return obj; &#125; /** * @param t * @return 返回t在数据库的id */ public int save(T t) &#123; Class c = t.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return 0; &#125; StringBuilder sql = new StringBuilder(); sql.append(\"insert into \") .append(((Table) c.getAnnotation(Table.class)).value()) .append(\"(\"); Field[] fields = c.getDeclaredFields(); List&lt;String&gt; fieldNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; columnNames = new ArrayList&lt;String&gt;(); for (Field field : fields) &#123; if (field.isAnnotationPresent(Column.class)) &#123; columnNames.add(field.getAnnotation(Column.class).value()); fieldNames.add(field.getName()); &#125; &#125; StringBuilder paramValue = new StringBuilder(\" values(\"); int i = 0; for (; i &lt; fieldNames.size(); i++) &#123; sql.append(columnNames.get(i)).append(\",\"); Object fieldValue = null; try &#123; StringBuilder sb = new StringBuilder(fieldNames.get(i)); sb.setCharAt(0, Character.toUpperCase(sb.charAt(0))); String methodName; String fieldNameType = c.getDeclaredField(fieldNames.get(i)).getGenericType().toString(); if (fieldNameType.equalsIgnoreCase(\"boolean\")) &#123; methodName = \"is\" + sb.toString(); &#125; else &#123; methodName = \"get\" + sb.toString(); &#125; Method method = c.getMethod(methodName); fieldValue = method.invoke(t); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; paramValue.append(generateStringByFieldValueType(fieldValue)); paramValue.append(\",\"); &#125; sql.setCharAt(sql.length() - 1, ')'); paramValue.setCharAt(paramValue.length() - 1, ')'); sql.append(paramValue); logger.info(sql.toString()); return super.executeInsert(sql.toString()); &#125; public int update(T t) &#123; Class c = t.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return 0; &#125; StringBuilder sql = new StringBuilder(); sql.append(\"update \") .append(((Table) c.getAnnotation(Table.class)).value()) .append(\" set \"); Field[] fields = c.getDeclaredFields(); StringBuilder whereStr = new StringBuilder(\"where \"); for (Field field : fields) &#123; if (field.isAnnotationPresent(Column.class)) &#123; StringBuilder sb = new StringBuilder(field.getName()); sb.setCharAt(0, Character.toUpperCase(sb.charAt(0))); String methodName; String fieldNameType = field.getGenericType().toString(); if (fieldNameType.equalsIgnoreCase(\"boolean\")) &#123; methodName = \"is\" + sb.toString(); &#125; else &#123; methodName = \"get\" + sb.toString(); &#125; Method method = null; Object fieldValue = null; try &#123; method = c.getMethod(methodName); fieldValue = method.invoke(t); if (fieldValue == null) &#123; continue; &#125; sql.append(field.getAnnotation(Column.class).value()).append(\"=\"); sql.append(generateStringByFieldValueType(fieldValue)).append(\",\"); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; else if (field.isAnnotationPresent(Id.class)) &#123; whereStr.append(field.getAnnotation(Id.class).value()).append(\"=\"); Method method; Object fieldValue = null; try &#123; StringBuilder sb = new StringBuilder(field.getName()); sb.setCharAt(0, Character.toUpperCase(sb.charAt(0))); String methodName; String fieldNameType = field.getGenericType().toString(); if (fieldNameType.equalsIgnoreCase(\"boolean\")) &#123; methodName = \"is\" + sb.toString(); &#125; else &#123; methodName = \"get\" + sb.toString(); &#125; method = c.getMethod(methodName); fieldValue = method.invoke(t); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; whereStr.append(generateStringByFieldValueType(fieldValue)); &#125; &#125; sql.setCharAt(sql.length() - 1, ' '); sql.append(whereStr); logger.info(sql.toString()); return super.executeUpdateAndDelete(sql.toString()); &#125; public int remove(int id, Class&lt;T&gt; t) &#123; T obj = null; StringBuilder sql = new StringBuilder(); try &#123; obj = t.newInstance(); Class c = obj.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return 0; &#125; sql.append(\"delete from \") .append(((Table) c.getAnnotation(Table.class)).value()); Field[] fields = c.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(Id.class)) &#123; sql.append(\" where \") .append(field.getAnnotation(Id.class).value()) .append(\"=\") .append(id); break; &#125; &#125; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; logger.info(sql.toString()); return super.executeUpdateAndDelete(sql.toString()); &#125; public List&lt;T&gt; list(int startRecord, int pageSize, Class&lt;T&gt; t) &#123; T obj = null; StringBuilder sql = new StringBuilder(); try &#123; obj = t.newInstance(); Class c = obj.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return null; &#125; Table table = (Table) c.getAnnotation(Table.class); String tableName = table.value(); sql.append(\"select * from \") .append(tableName) .append(\" limit \") .append(startRecord) .append(\",\").append(pageSize); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; logger.info(sql.toString()); return super.executeList(sql.toString(), t); &#125; public int count(Class&lt;T&gt; t) &#123; T obj = null; StringBuilder sql = new StringBuilder(); try &#123; obj = t.newInstance(); Class c = obj.getClass(); if (!c.isAnnotationPresent(Table.class)) &#123; return 0; &#125; Table table = (Table) c.getAnnotation(Table.class); String tableName = table.value(); sql.append(\"select count(*) from \") .append(tableName); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; logger.info(sql.toString()); return super.getCountRow(sql.toString()); &#125; /** * 判断属性值得类型来设置进行sql拼接时是否需要加“”或其他处理 * * @param fieldValue * @return */ private String generateStringByFieldValueType(Object fieldValue) &#123; StringBuilder stringBuilder = new StringBuilder(); if (fieldValue instanceof String) &#123; stringBuilder.append(\"\\\"\").append(fieldValue).append(\"\\\"\"); &#125; else if (fieldValue instanceof java.util.Date) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss\"); fieldValue = simpleDateFormat.format(fieldValue); stringBuilder.append(\"\\\"\").append(fieldValue).append(\"\\\"\"); &#125; else &#123; stringBuilder.append(fieldValue); &#125; return stringBuilder.toString(); &#125;&#125; 到此，基本完成，配置好db.properties，如下：12345#####################mysql#######################driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/dborm?useUnicode=true&amp;characterEncoding=utf-8username=rootpassword=123456 接下来就是测试工作。 新建一个User类，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import com.panhainan.dborm.annotation.Column;import com.panhainan.dborm.annotation.Id;import com.panhainan.dborm.annotation.Table;import java.util.Date;@Table(\"t_user\")public class User &#123; @Id(\"id\") private long id; @Column(\"account\") private String account; @Column(\"password\") private String password; @Column(\"real_name\") private String realName; @Column(\"age\") private int age; @Column(\"register_time\") private Date registerTime; @Column(\"usable\") private boolean usable; public User() &#123; &#125; public User(long id,String realName, int age, Date registerTime, boolean usable) &#123; this.id = id; this.realName = realName; this.age = age; this.registerTime = registerTime; this.usable = usable; &#125; public User(String account, String password, String realName, int age, Date registerTime, boolean usable) &#123; this.account = account; this.password = password; this.realName = realName; this.age = age; this.registerTime = registerTime; this.usable = usable; &#125; public User(long id, String account, String password, String realName, int age, Date registerTime, boolean usable) &#123; this.id = id; this.account = account; this.password = password; this.realName = realName; this.age = age; this.registerTime = registerTime; this.usable = usable; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", account='\" + account + '\\'' + \", password='\" + password + '\\'' + \", realName='\" + realName + '\\'' + \", age=\" + age + \", registerTime=\" + registerTime + \", usable=\" + usable + '&#125;'; &#125; 此处为对应get,set方法....&#125; 新建一个UserRepository类用来实现User对象的持久化操作，需要继承CrudRepository类，如下： 最后新建一个测试类UserRepositoryTest类，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.junit.Test;import java.util.Date;import java.util.List;import java.util.logging.Logger;public class UserRepositoryTest &#123; private Logger logger = Logger.getLogger(this.toString()); @Test public void get()&#123; UserRepository userRepository = new UserRepository(); User user = userRepository.get(3,User.class); logger.info(user.toString()); &#125; @Test public void save()&#123; UserRepository userRepository = new UserRepository(); User user = new User(\"admin1\",\"1111\",\"管理员1\",10,new Date(),false); int result = userRepository.save(user); logger.info(String.valueOf(result)); &#125; @Test public void update()&#123; UserRepository userRepository = new UserRepository(); User user = new User(1,\"张三\",50,new Date(),false); int result = userRepository.update(user); logger.info(String.valueOf(result)); &#125; @Test public void remove()&#123; UserRepository userRepository = new UserRepository(); int result = userRepository.remove(3,User.class); logger.info(\"result:\"+result); &#125; @Test public void list()&#123; UserRepository userRepository = new UserRepository(); List&lt;User&gt; users = userRepository.list(0,2,User.class); logger.info(users.toString()); &#125; @Test public void count()&#123; UserRepository userRepository = new UserRepository(); int result = userRepository.count(User.class); logger.info(\"result:\"+result); &#125;&#125; 运行即可查看到对应结果。 源码请前往GitHub查看，地址：github.com/panhainan/dborm","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"Java注解","slug":"Java注解","permalink":"http://panhainan.github.io/tags/Java注解/"},{"name":"简单ORM框架","slug":"简单ORM框架","permalink":"http://panhainan.github.io/tags/简单ORM框架/"}]},{"title":"Java注解以及自定义注解","slug":"Java注解以及自定义注解","date":"2018-03-21T14:46:07.000Z","updated":"2019-09-30T18:49:29.800Z","comments":true,"path":"2018/03/21/Java注解以及自定义注解/","link":"","permalink":"http://panhainan.github.io/2018/03/21/Java注解以及自定义注解/","excerpt":"Java注解想必很多人都见到过，这里就带大家来了解一下Java的几个常用注解的意思以及Java元注解和自定义注解的实现。","text":"Java注解想必很多人都见到过，这里就带大家来了解一下Java的几个常用注解的意思以及Java元注解和自定义注解的实现。 内容大纲 Java注解 @Override @Deprecated @SuppressWarnings 元注解 @Target @Target @Retention @Inherited @Documented 自定义注解 语法要求 解析注解 自定义注解 @Description 使用自定义注解 @Description 通过反射进行注解解析 Java注解@Override 重写注解：一般用于方法上，表示该方法重写父类或者接口的方法。 如父类Person：12345public class Person &#123; void eat()&#123; System.out.println(\"eat anything\"); &#125;&#125; 子类Child重写eat方法需要使用到@Override注解：123456public class Child extends Person &#123; @Override public void eat() &#123; System.out.println(\"eat something\"); &#125;&#125; @Deprecated 废弃注解：可以用于类、方法、成员变量上，表示该类、方法、成员变量已经被废弃，不建议使用 父类Person原来有个look方法：123void look()&#123; System.out.println(\"look\");&#125; 但是开发后期发现这个方法不合理，如有些人天生看不见，但是又不能删除，因为可能有些地方已经用到了这个方法；故需要将其标志为废弃方法，不建议使用，加@Deprecated注解，变成：1234@Deprecatedvoid look()&#123; System.out.println(\"look\");&#125; @SuppressWarnings 忽略废弃注解：用于应对需要使用被@Deprecated标识的类、方法、成员变量时，忽略如test 标识的情况。 当在某些情况下需要用到Person类的look方法时，发现它已经被标识为已废弃，此时调用该方法就会出现在调用处方法名会有删除线，表示不建议使用，这里就需要用到@SuppressWarnings(“deprecation”)，即在此处消除已废弃的定义12345@SuppressWarnings(\"deprecation\")//消除look方法被@Deprecated注解定义后 public void test()&#123; Person p = new Child(); p.look(); &#125; 12345678910@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description&#123; String desc(); String author(); int age() default 18;&#125; 元注解 元注解，即用于定义注解的注解。1234@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented @Target 作用域：构造函数，字段，局部变量，方法，包，参数，类，接口 @Retention 生命周期：源码，编译时，运行时 @Inherited （标识注解）允许子类继承 @Documented javadoc 自定义注解语法要求 使用@interface关键字定义注解； 成员变量必须以无参数无异常方式声明； 可以用default给成员指定默认值； 成员类型是受限的，合法的类型包括原始类型（即int，double等等）及String，Class，Annotation，Enumeration； 如果注解只有一个成员，则成员名约定取名为value()，在使用时可以忽略成员名和赋值号（=）； 注解类可以没有成员，没有成员的注解称为标识注解。 123456public @interface Description&#123; String desc(); String author(); int age() default 18;&#125; 解析注解自定义注解 @Description 首先定义一个简单自定义注解 @Description 如下：12345678910import java.lang.annotation.*;@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description&#123; String value();&#125; 使用自定义注解 @Description 在Child的类名上添加 @Description(&quot;I am a class(Child) annotation&quot;) 在Child的方法名上添加 @Description(&quot;I am a method (eat) annotation&quot;) 通过反射进行注解解析 新建一个ParseDescription类，如下：12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.util.logging.Logger;public class ParseDescription &#123; private static Logger logger = Logger.getLogger(\"com.panhainan.annotation.ParseDescription\"); public static void main(String[] args) &#123; try &#123; //解析注解 //1.使用类加载器加载类 Class c = Class.forName(\"com.panhainan.annotation.Child\"); //2.找到类上的注解 boolean istExist = c.isAnnotationPresent(Description.class); if(istExist)&#123; //3.拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); logger.info(d.value()); &#125; //4.找到方法上的注解 Method[] methods = c.getMethods(); for (Method method : methods)&#123; if(method.isAnnotationPresent(Description.class))&#123; Description md = (Description)method.getAnnotation(Description.class); logger.info(md.value()); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行可以得到如下结果：1234三月 22, 2018 11:51:53 上午 com.panhainan.annotation.ParseDescription main信息: I am a class(Child) annotation三月 22, 2018 11:51:53 上午 com.panhainan.annotation.ParseDescription main信息: I am a method (eat) annotation 读者可以一一尝试@Target、@Retention、@Inherited、@Documented的不同的定义法，来尝试元注解的用途，这里就不一一演示了。 当然这个例子只是第一个简单的自定义注解实例，后面会出复杂的例子来演示自定义注解的妙用。","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"Java注解","slug":"Java注解","permalink":"http://panhainan.github.io/tags/Java注解/"},{"name":"自定义注解","slug":"自定义注解","permalink":"http://panhainan.github.io/tags/自定义注解/"}]},{"title":"SpringMVC数据绑定(JSON格式和XML格式)","slug":"SpringMVC数据绑定-JSON格式和XML格式","date":"2018-03-20T06:39:18.000Z","updated":"2019-09-30T19:15:42.629Z","comments":true,"path":"2018/03/20/SpringMVC数据绑定-JSON格式和XML格式/","link":"","permalink":"http://panhainan.github.io/2018/03/20/SpringMVC数据绑定-JSON格式和XML格式/","excerpt":"接着上篇对于form表单形式和url直接传参形式讲解，继续进行对JSON格式和XML格式数据解析绑定的讲解。","text":"接着上篇对于form表单形式和url直接传参形式讲解，继续进行对JSON格式和XML格式数据解析绑定的讲解。 内容大纲 1. JSON格式 1.1 简单对象 1.2 简单对象包含对象，即多层级对象 1.3 对象数组 1.4 集合List类型 2. XML格式 开发工具 Spring版本: 4.1.6.RELEASE IDE工具版本: IntelliJ IDEA 2017 请求模拟工具: Postman 1. JSON格式 实现SpringMVC对于JSON数据解析绑定需要进行以下4步： 1). 导入json的jar包：jackson，如对应的maven的pom为 12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt; 2). 在spring-mvc的配置文件中添加对于json数据解析绑定的配置，这里可以通过&lt;mvc:annotation-driven/&gt;直接快速使用； 3). 前台发送请求必须注明[“Content-Type”:”application/json”]，同时需要将传递的JSON数据字符串化，如User对象的JSON字符串形式为：1234&#123; \"name\":\"Tom\", \"age\":20&#125; 4). 在controller中进行接收时，需要在参数位置前指定 @RequestBody 注解。 1.1 简单对象（简单对象包含对象，即多层级对象） 继续在上一篇中提到的DataBindController类中增加以下方法：1234567891011121314/** * JSON格式简单对象 * post方式：http://localhost:8080/springmvc/jsonObjectType * 注明[\"Content-Type\":\"application/json\"]以及参数为&#123; \"name\":\"Tom\",\"age\":20 &#125; * @param user * @return json串 */@RequestMapping(\"/jsonObjectType\")@ResponseBodypublic String jsonObjectType(@RequestBody User user)&#123; String msg = user.toString(); logger.info(msg); return msg;&#125; 打开Postman，填写好相关参数，提交post请求，可以看到如下结果： 返回值 User{name=&#39;Tom&#39;, age=20} 表示请求成功。 1.2 简单对象包含对象，即多层级对象 继续测试简单对象包含对象（即多层级对象）,增加两个类ContactInfo{phone,email}和Person{name,age,contactInfo}，实现get，set和toString方法。 加入以下代码到DataBindController类中，提交post请求并填写好请求参数。123456789101112131415/** * JSON格式多层级简单对象 * post方式：http://localhost:8080/springmvc/jsonObjectsType * 注明[\"Content-Type\":\"application/json\"]以及参数为&#123; \"name\":\"Tom\",\"age\":20,\"contactInfo\":&#123; \"phone\":\"18074609999\",\"email\":\"test@yeah.net\"&#125; &#125; * * @param person * @return json串 */@RequestMapping(\"/jsonObjectsType\")@ResponseBodypublic String jsonObjectsType(@RequestBody Person person) &#123; String msg = person.toString(); logger.info(msg); return msg;&#125; 返回结果为 { &quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20,&quot;contactInfo&quot;:{ &quot;phone&quot;:&quot;18074609999&quot;,&quot;email&quot;:&quot;test@yeah.net&quot;} }，表示请求成功。 1.3 对象数组 同上述简单对象类似，只需要在参数位置将其改为数组形式即可，代码如下：1234567891011121314151617/** * JSON格式简单对象数组 * post方式：http://localhost:8080/springmvc/jsonObjectArrayType * 注明[\"Content-Type\":\"application/json\"]以及参数为[&#123;\"age\":18,\"name\":\"Tom\"&#125;,&#123;\"age\":10,\"name\":\"Jack\"&#125;] * @param users * @return json串 */@RequestMapping(\"/jsonObjectArrayType\")@ResponseBodypublic String jsonObjectArrayType(@RequestBody User[] users)&#123; StringBuilder msg = new StringBuilder(); for (User user :users)&#123; msg.append(user.toString()+\" \"); &#125; logger.info(msg.toString()); return msg.toString();&#125; 测试结果会得到 User{name=&#39;Tom&#39;, age=18} User{name=&#39;Jack&#39;, age=10}，请求成功。 1.4 集合List类型 将参数形式改为List即可，代码如下：123456789101112131415161718/** * JSON格式简单对象List集合形式 * post方式：http://localhost:8080/springmvc/jsonObjectListType * 注明[\"Content-Type\":\"application/json\"]以及参数为[&#123;\"age\":18,\"name\":\"Tom\"&#125;,&#123;\"age\":10,\"name\":\"Jack\"&#125;] * * @param userList * @return */@RequestMapping(\"/jsonObjectListType\")@ResponseBodypublic String jsonObjectListType(@RequestBody List&lt;User&gt; userList) &#123; StringBuilder msg = new StringBuilder(); for (User user : userList) &#123; msg.append(user.toString() + \" \"); &#125; logger.info(msg.toString()); return msg.toString();&#125; 可以看到测试结果与数组形式的结果相同，也是User{name=&#39;Tom&#39;, age=18} User{name=&#39;Jack&#39;, age=10}，请求成功。 这里需要注意参数形式为List&lt;User&gt;，如果像form表单那样传UserListVO时则会提示400错误。 2. XML格式 实现SpringMVC对于JSON数据解析绑定需要进行以下4步： 1). 导入xml的jar包：因为spring-oxm提供对xml的支持，故引入spring-oxm即可; 2). 在spring-mvc的配置文件中添加对于xml数据解析绑定的配置，这里可以通过&lt;mvc:annotation-driven/&gt;直接快速使用 3). 前台发送请求必须注明[“Content-Type”:”application/xml”]， 同时需要注意，对于传输的指定对象，需要在对象的类里面进行相关操作， 在类上面添加@XmlRootElement(name=”如article”)，在其属性的所有get方法上根据需要分别添加对应的@XmlElement(name = “如title,content”)，分别表示xml文件中的根节点和节点 同时注意参数的形式，如Article对象，12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;article&gt; &lt;title&gt;here is title&lt;/title&gt; &lt;content&gt;here is content&lt;/content&gt;&lt;/article&gt; 4). 在controller中进行接收时，需要在参数位置前指定 @RequestBody 注解。 继续添加以下方法到DataBindController类中，在Postman中填写好参数，提交post请求，123456789101112131415/** * XML格式 * post方式：http://localhost:8080/springmvc/xmlType * 注明[\"Content-Type\":\"application/xml\"]以及参数为 * &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;article&gt;&lt;title&gt;here is title&lt;/title&gt;&lt;content&gt;here is content&lt;/content&gt;&lt;/article&gt; * @param article * @return json串 */@RequestMapping(\"/xmlType\")@ResponseBodypublic String xmlType(@RequestBody Article article)&#123; String msg = article.toString(); logger.info(msg); return msg;&#125; 结果显示 Article{title=&#39;here is title&#39;, content=&#39;here is content&#39;},表示请求成功。 本文的代码可以在github上找到，地址为：github.com/panhainan/spring-family","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/tags/SpringMVC/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://panhainan.github.io/tags/数据绑定/"}]},{"title":"SpringMVC数据绑定(form表单和url形式传参)","slug":"SpringMVC数据绑定-form表单和url形式传参","date":"2018-03-19T06:45:02.000Z","updated":"2019-09-30T18:49:29.803Z","comments":true,"path":"2018/03/19/SpringMVC数据绑定-form表单和url形式传参/","link":"","permalink":"http://panhainan.github.io/2018/03/19/SpringMVC数据绑定-form表单和url形式传参/","excerpt":"Spring MVC目前开发用的很多，对于数据绑定这块很多人经常遇到一些小问题，就是因为对于数据绑定不够熟悉，今天十六子就和大家一起学习一下对于form表单以及url形式传递参数方式的数据绑定。","text":"Spring MVC目前开发用的很多，对于数据绑定这块很多人经常遇到一些小问题，就是因为对于数据绑定不够熟悉，今天十六子就和大家一起学习一下对于form表单以及url形式传递参数方式的数据绑定。 内容大纲 1. 基本数据类型 2. 包装类型 3. 数组类型 4. 简单对象（简单对象包含对象，即多层级对象） 5. 同属性多对象 6. 集合List类型 开发工具 Spring版本: 4.1.6.RELEASE IDE工具版本: IntelliJ IDEA 2017 请求模拟工具: Postman 以下的6种方式的讲解在代码的注释部分基本上已经讲明，这里就以第1基本数据类型为例介绍以下如何按照注释所述进行测试使用。 1.基本数据类型 在配置好SpringMVC的项目环境后，新建一个 DataBindController.java ，在类名上引入@Controller注解，表示这是一个Controller Bean，接着将以下代码copy放在其中，logger变量可以在类中定义 Logger logger = Logger.getLogger(this.toString());。123456789101112131415161718/** * 参数为基本数据类型，如int * 此时param不能为空，否则会出现 HTTP Status 400 – Bad Request * 可以通过@RequestParam注解来设置别名，默认值，是否必须等 * get方式 : http://localhost:8080/springmvc/basicType?param=16666 * post方式 : http://localhost:8080/springmvc/basicType * post方式注意: 指定param = 16 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"] * * @param param * @return json串 */@RequestMapping(\"/basicType\")@ResponseBodypublic String basicType(int param) &#123; String msg = \"the param is \" + param; logger.info(msg); return msg;&#125; 接着启动服务器，打开Postman，进行请求模拟测试。 测试get方式，选择GET，输入 http://localhost:8080/springmvc/basicType?param=16666 结果如下图： 可以看出结果为 the param is 16666 ,正是方法返回的值（注意这里@ResponseBody注解表示返回为JSON字符串格式）。 测试post方式，选择POST，输入 http://localhost:8080/springmvc/basicType ，点击Body，选中x-www-form-urlencoded 模式，填入key为param，value为16，提交，结果如下图： 可以看出结果为 the param is 16 ,正是方法返回的值。 2. 包装类型1234567891011121314151617/** * 参数为包装类型，如Integer * 此时param可以为空，为空时值为null * get方式 : http://localhost:8080/springmvc/wrapperType?param=16666 * post方式 : http://localhost:8080/springmvc/wrapperType * post方式注意: 指定param = 16 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"] * * @param param * @return json串 */@RequestMapping(\"/wrapperType\")@ResponseBodypublic String wrapperType(Integer param) &#123; String msg = \"the param is \" + param; logger.info(msg); return msg;&#125; 3. 数组类型12345678910111213141516171819/** * 参数为数组类型 * get方式 : http://localhost:8080/springmvc/arrayType?params=Tome&amp;params=Jack * post方式 : http://localhost:8080/springmvc/arrayType * post方式注意: 指定params=Tome&amp;params=Jack 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"] * * @param params * @return json串 */@RequestMapping(\"/arrayType\")@ResponseBodypublic String arrayType(String[] params) &#123; StringBuilder msg = new StringBuilder(\"params are : \"); for (String p : params) &#123; msg.append(p + \" \"); &#125; logger.info(msg.toString()); return msg.toString();&#125; 4. 简单对象（简单对象包含对象，即多层级对象） 此处要用到User对象，属性有 name , age ,同时有它们的get和set方法，请读者自己手动建立，或者在本文下方去github下载本项目。12345678910111213141516171819/** * 参数为简单对象（简单对象包含对象，即多层级对象） * get方式： http://localhost:8080/springmvc/objectType?name=Tom&amp;age=18 * post方式： http://localhost:8080/springmvc/objectType * post方式注意: 直接指定name=Tom&amp;age=18（不需要加user.） 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"] * &lt;p&gt; * 注意：若简单对象内部还包含一个对象如Contact contact，Contact有address和phone两个属性 * 那么参数传递的方式为name=Tom&amp;age=18&amp;contact.address=北京路&amp;phone18074600000 * * @param user * @return json串 */@RequestMapping(\"/objectType\")@ResponseBodypublic String objectType(User user) &#123; String msg = \"user is : \" + user; logger.info(msg); return msg;&#125; 5. 同属性多对象 此处要用到Book对象，属性有 name , author ,同时有它们的get和set方法，请读者自己手动建立，或者在本文下方去github下载本项目。 12345678910111213141516171819202122232425262728293031/** * 同属性多对象 * get方式：http://localhost:8080/springmvc/objectsAttributeType?user.name=Jack&amp;user.age=19&amp;book.name=SpringBoot * post方式：http://localhost:8080/springmvc/objectsAttributeType * post方式注意: 指定name=Tom&amp;age=18 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"]。 * 会出现结果两个对象的name都为Tom。 * 若使用user.name方式则会显示null * 因此需要使用到下面的initParamUser和initParamBook方法 * * @param user * @param book * @return json串 */@RequestMapping(\"/objectsAttributeType\")@ResponseBodypublic String objectsAttributeType(User user, Book book) &#123; String msg = \"user is : \" + user + \",book is : \" + book; logger.info(msg); return msg;&#125;//@InitBinder注解在本controller启动时会进行初始化@InitBinder(\"user\")public void initParamUser(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(\"user.\");&#125;@InitBinder(\"book\")public void initParamBook(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(\"book.\");&#125; 6. 集合List类型 此处要用到UserListVO对象，属性有 List&lt;User&gt; userList , 同时有它们的get和set方法，请读者自己手动建立，或者在本文下方去github下载本项目。 1234567891011121314151617181920/** * 参数为集合List类型（Set类型不太兼容，Map类型需要注意键值对，二者都不太常用） * get方式：http://localhost:8080/springmvc/listType?userList[0].name=gaven&amp;userList[1].name=jack * post方式：http://localhost:8080/springmvc/listType * 指定userList[0].name=gaven&amp;userList[1].name=jack * 同时指定[\"Content-Type\",\"application/x-www-form-urlencoded\"]。 * * @param userListVO * @return json串 */@RequestMapping(\"/listType\")@ResponseBodypublic String listType(UserListVO userListVO) &#123; StringBuilder msg = new StringBuilder(\"userList are : \"); for (User user : userListVO.getUserList()) &#123; msg.append(user + \" \"); &#125; logger.info(msg.toString()); return msg.toString();&#125; 因为集合类型Set和Map不太常用，而且SpringMVC对于Set的兼容性不好，故此处没有介绍。 本文的代码可以在github上找到，地址为：github.com/panhainan/spring-family","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://panhainan.github.io/tags/SpringMVC/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://panhainan.github.io/tags/数据绑定/"}]},{"title":"Java相关开发环境配置","slug":"Java相关开发环境配置","date":"2018-03-15T14:41:47.000Z","updated":"2019-09-30T18:49:29.798Z","comments":true,"path":"2018/03/15/Java相关开发环境配置/","link":"","permalink":"http://panhainan.github.io/2018/03/15/Java相关开发环境配置/","excerpt":"","text":"一、Java配置 配置 JAVA_HOME：安装位置，如C:\\app\\Java\\jdk1.8.0_161 配置CLASSPATH：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 配置Path：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 检测：java -version 二、Maven配置 MAVEN_HOME ：D:\\Tools\\Maven3\\apache-maven-3.2.5 配置Path： ;%MAVEN_HOME%\\bin 检测：mvn --version 三、免安装MySQL配置第1步：下载解压 将解压目录下默认文件 my-default.ini 拷贝一份，改名 my.ini 复制下面的配置信息到 my.ini 保存 如果没有my-default.ini,可自己新建my.ini或者从其他地方中获取 12345678910111213141516171819202122[mysqld]#绑定IPv4和3306端口bind-address = 0.0.0.0port = 3306# 设置mysql的安装目录,即你解压缩安装包的位置basedir=D:/Tools/mysql#需要注意到的是这里是斜杠&quot;/&quot; 而不是Windows里面的反斜杠&apos;\\&quot;# 设置mysql数据库的数据的存放目录datadir=D:/Tools/mysql/data# 允许最大连接数max_connections=200#设置字符集为utf8loose-default-character-set=utf8#开启查询缓存explicit_defaults_for_timestamp=truesql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client]#设置客户端字符集port=3306loose-default-character-set=utf8[WinMySQLadmin]Server=D:/Tools/mysql/bin/mysqld.exe 第2步：添加环境变量 MYSQL_HOME: D:/Tools/mysql/ Path:%MYSQL_HOME%\\bin 第3步：将mysql注册为windows系统服务 注意：一下操作都是在以管理员身份 运行 命令提示符 的前提下 但是如果你不是以管理员的身份打开命令提示符，那么执行上述命令时就会提示：Install/Remove of the service denied!(服务安装被拒绝) 从控制台进入到MySQL解压目录下的 bin 目录下 输入服务安装命令：mysqld install MySQL --defaults-file=&quot;c:\\my.ini&quot; Windows默认会在“C:\\Program Files\\MySQL\\mysql-5.6.13-win32\\bin”下面启动mysqld命令，需要在注册表中将MySQL服务ImagePath修改为”C:\\mysql\\bin\\mysqld” –defaults-file=c:\\mysql\\my.ini MySQL 安装成功后会提示服务安装成功。 注：my.ini文件放在MySQL解压后的根目录下 移除服务命令为：mysqld remove 第4步：启动关闭MySQL服务 注意：一下操作都是在以管理员身份运行命令提示符的前提下 启动服务命令为：net start mysql 关闭服务命令为：net stop mysql 第5步：修改 root 账号的密码 刚安装完成时root账号默认密码为空，此时可以将密码修改为指定的密码。如：123456 123456c:&gt;mysql –urootmysql&gt;show databases;mysql&gt;use mysql;mysql&gt;UPDATE user SET password=PASSWORD(&quot;123456&quot;) WHERE user=&apos;root&apos;;mysql&gt;FLUSH PRIVILEGES;mysql&gt;QUIT 四、Git配置 安装完成后，打开Git Bush，在命令行输入： git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub 打开“Account settings”，“SSH Keys”页面。 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 五、Spring Boot CLI配置 下载分发包,解压，将bin目录路径添加到环境变量的PATH里面即可。","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"开发环境配置","slug":"开发环境配置","permalink":"http://panhainan.github.io/tags/开发环境配置/"}]},{"title":"使用命令行编译运行Java程序","slug":"使用命令行编译运行Java程序","date":"2016-09-01T15:00:58.000Z","updated":"2019-09-30T18:49:29.805Z","comments":true,"path":"2016/09/01/使用命令行编译运行Java程序/","link":"","permalink":"http://panhainan.github.io/2016/09/01/使用命令行编译运行Java程序/","excerpt":"","text":"对这个一直有很大的疑惑，总处于那种似懂非懂的感觉，相信很多人都在开始学Java的时候用了一小会command line来运行Java application，但是很少有人用这个来尝试多个class或者使用了external jar。昨晚开始想了一下，来试试这样操作的样子，然后一弄就是几个小时，搞不定，1.多了必须睡觉，想着明天还得上班。 今天下了班，然后再开始尝试，网上找到了两篇博客，也是看的困惑，不知道是他写的比较乱还是什么，在自己的环境总是运行起来，百度一堆都是些垃圾，然后终于还是想着用几个关键字来Google一下，然后就把自己的问题给解决了。这里保留一份这个问题的记录。 一、使用命令行编译运行引用jar包的Java程序 我建了一个项目（就是一个空文件夹），名字叫做message，然后在里面按照Java project 的structure来建了一个src的文件，接着里面弄了org.fire.entity和org.fire.test两个package，其实在文件浏览器里面都是文件夹形式。然后分别在entity里面建了一个Message class，在test里面建了一个Test class，整个structure图如下： 两个Java class 的内容如下：123456789101112package org.fire.entity;/** * Message.java * Created by Pan on 2016/8/31. */public class Message &#123; public Message() &#123; &#125; public void saySomethingWithYou(String message) &#123; System.out.println(message); &#125;&#125; 123456789package org.fire.test;import org.fire.entity.Message;public class Test &#123; public static void main(String[] args) &#123; // write your code here Message message = new Message(); message.saySomethingWithYou(\"nice to meet you!\"); &#125;&#125; 然后用javac来compile这个项目，将命令行的path切换到src下面，使用javac开始编译 javac org\\fire\\entity\\Message.java org\\fire\\test\\Test.java 然后使用java来run Test 这个类的main方法，看看有没有达到相应的result。 java org.fire.test.Test 结果显示“nice to meet you!” 正好是main中需要print的value。 successful。 注意，以上都没有指定生成的字节码文件.class放置在具体位置，因此会默认将每个.java对应的.class放置在.java同一个目录。 我们可以使用 -d bin 来指定.class生成的位置，这里可以尝试一下： 这里可能会注意到有 -sourcepath src 这是因为目前我已经不在src目录下了，而是在src上级目录下，所以指定src为源代码文件夹位置。 整个过程还有可以优化的地方，就是在使用javac来compile的时候。 think， 如果有多个java class 怎么办，一个一个write？It’s impossible。 这里将一种方便的方法，不过方便可能也是针对Linux环境说的。 新建一个txt放在src目录下吧，内容就按照如下方式写： result如下图： successful。 上面所讲的source.txt在linux的环境下不需要手写了，使用命令： find -name &quot;*.java&quot; &gt; source.txt 即可生成。 二、使用命令行编译运行有引用外部jar的Java程序（一）将项目打包成jar 先将上面的项目打包成一个jar文件(jar中不包含源码，所以在上述javac操作后的bin目录下进行以下操作) 在bin目录下新建一个名为“META-INF”文件夹，然后在里面建一个名为“MANIFEST.MF”文件，注意后缀为mf，然后在MANIFEST.MF中写入一下代码（根据自己实际情况编写） 注意事项：第一行是固定格式，定义版本号，第二行就是指明主类的位置可以用空格分开多个声明，注意冒号之后要有一个空格；然后注意的就是后面需要空出2行。 还要注意把bin下不用的文件删掉，即留下下图所示 然后在bin目录下的command line运行： jar -cvfm message.jar META-INF\\MANIFEST.MF . 然后bin目录下多了一个文件，如图： 可以将message解压看看内部内容，可以发现meta-inf下面的manifest.mf文件变成了这样， 程序运行结果： successful。 这里测试的只有一个主类，没有测试过多个主类，如果存在多个主类则需要在manifest.mf中定义多个，并且在运行的时候需要指定运行哪一个，假设这里有多个主类，我们需要运行org.fire.test.Test主类，则是在上面的基础上加上org.fire.test.Test即可，如图： （二）新建项目来运行测试外部jar 新建一个项目，然后弄个TestMessage class，结构如下： 然后用javac compile,java run，result 如下： project 的structure如下： 注意： 在使用javac 来compile的时候，linux下分割jar采用冒号“：”，windows下采用分号“；”，在参考blog的第一篇文中有讲： Task Lets say we have a fairly standard java project that consists of three top level folders: /bin - empty folder that will contain compiled .class files /lib - contains third party .jar files /src - contains .java source files Our task would be to compile and launch the project from its root folder. We will use Windows OS as example (on Unix systems the only difference would be path separation symbol - “:” instead of “;”). 在使用java 来run 的时候，指定了bin为当前程序运行的目录。在参考blog的第一篇文中有讲，如下段： Some Notes About Classpath Lets say during Application.java compilation a compiler stumbles upon somecom.example.Util class. How to find it in the file system? According to Java file naming rules,Util class has to be located somewhere in Util.java file under /com/example/ folder, but where to start searching for this path? Here is where classpath comes into play which sets the starting folder for searching for classes. Classpath can be set in 3 different ways: 1. If no –classpath parameter is passed, CLASSPATH environment variable is used 2. If CLASSPATH environment variable is not found, current folder (“.”) is used by default 3. If –classpath is explicitly set as a command line parameter, it overrides all other values The fact that classpath when set overrides default value (current folder) can cause some unexpected results. For example if we don’t use any third party libraries, only our own com.example.Util class, and try to compile Application.java from the src folder: javac com/example/Application.java this would work, but then if we decide to add a third party libarary to the classpath: javac -cp lib/lib1.jar com/example/Application.java it would cause an error: package com.example.Util does not exist This happens because when we set -cp lib/lib1.jar we override default value for the classpath - current folder. Now a compiler will be looking for all classes only inside that jar file. To fix this we need to explicitly add the current folder to the classpath: javac -cp .;lib/lib1.jar com/example/Application.java 好了，到此，这篇blog也是差不多了，其实还有很多东西讲的都不清楚，大家可以互相讨论，下面留言即可，我的blog停了将近 一年了，也是自己的问题，现在开了，互动会很快的，不要觉得博主不会看评论，先试试回答，不会有错的。 这里提醒大家，最好用Google来进行English search，即使Google搜索再好，天朝内部的程序员社区却已经不好了，所以你不论是用百度还是用Google搜到的很多都是一样的rubbish。 Bear in mind : Google Search in English 。 参考blog（order by quality）： http://www.sergiy.ca/how-to-compile-and-launch-java-code-from-command-line/ http://stackoverflow.com/questions/17140512/how-to-compile-multiple-java-files-when-there-are-java-files-in-other-packages http://www.cnblogs.com/freeweb/p/5251358.html http://stackoverflow.com/questions/13657849/run-java-application-from-command-line-with-external-jar-files http://www.cnblogs.com/freeweb/p/5251358.html http://www.importnew.com/11370.html","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"命令行运行Java程序","slug":"命令行运行Java程序","permalink":"http://panhainan.github.io/tags/命令行运行Java程序/"}]},{"title":"Java关键字之final和finally以及finalize","slug":"Java关键字之final和finally以及finalize","date":"2015-04-20T14:31:17.000Z","updated":"2019-09-30T18:49:29.798Z","comments":false,"path":"2015/04/20/Java关键字之final和finally以及finalize/","link":"","permalink":"http://panhainan.github.io/2015/04/20/Java关键字之final和finally以及finalize/","excerpt":"这是Java程序员面试宝典中一道面试题，同时很多公司企业面试的时候也喜欢问这道题，前些天一位学长(斌哥)回来一起聚聚的时候还说自己面试的时候遇到了这道题。现在我们就来讲讲这道题，加深自己的理解。全都是文字性的东西，讲的可能比较乏味，但是应该挺好懂的，不懂的可以一起交流。","text":"这是Java程序员面试宝典中一道面试题，同时很多公司企业面试的时候也喜欢问这道题，前些天一位学长(斌哥)回来一起聚聚的时候还说自己面试的时候遇到了这道题。现在我们就来讲讲这道题，加深自己的理解。全都是文字性的东西，讲的可能比较乏味，但是应该挺好懂的，不懂的可以一起交流。 final 想必大家都知道这是Java中定义常量的一个关键字吧;不过它可不止这一个用处啊，下面细细讲来。 1. final+变量v组合，即使用final定义变量v 解释：变量v一旦被初始化，则不能再被修改了。 这里的初始化有两个地方，一是定义的时候初始化，二是在构造函数中。二者只能选其一，而且初始化之后便只能读取不能修改了。 这里的不能被修改对不同的变量有不同的定义。对于基本类型定义的普通变量v来说，是指v的值不能被改变，即就是常量了。对于是类定义的对象变量v来说，是指v的引用不可变。 针对这一组合还有一种比较特殊的用法，就是在方法的形式参数中使用。这一用法对于基本类型的变量是没有实际意义的，因为Java中的方法调用在传基本类型的参数时是传值调用的；但是对于对象变量很实用，因为Java中的方法调用在传对象时传的是对象的引用，而如果在调用的这个方法体中的某处修改了该对象的引用可能会影响到其他地方使用该对象变量的引用，所以这里就需要用到final定义形式参数对象变量不可变。 2. final+方法m组合，即使用final关键字定义方法m 为什么要将方法定义为final？我们来看看产生这个组合的需求是什么。 需求有以下两点： 认为这个方法提供的功能已经满足了自己的要求，不需要并且不允许通过继承等手段来覆盖重写这个方法，这里是允许继承这个方法直接使用的，但是不允许修改了。 允许编译器将所有对该方法的调用转换为行内(inline)调用的机制，即是把调用该方法的代码直接转换为该方法的全部代码，而不是通过保存断点、压栈等手段进入到该方法。可以看出这样会使程序免去了方法调用的时间，使得效率提高了一些；但是得注意m的方法体比较小，并且调用该方法的地方不多，只是偶尔使用一下，否则会适得其反。 哈哈，现在应该知道了final+方法的组合的用法了吧。 3. final+类c组合，即是final关键字定义类 与上述讲方法的有点类似的地方，final定义类是表示此类c被认为设计的很完美了，不需要进行修改或者扩展等。所以final定义的类c是不能被继承的，也说明了final关键字不能和abstract关键字一起使用。对于final类c中的成员变量，可以定义为final，可以不定义；而c中的方法则都是final类型的，不管是否加关键字final。 finally 这个大家应该经常在try语句中看到吧，相信应该都比较懂它的功能。这里解释一下，在try catch语句块中，后面建议加一个finally块，这样被定义在finally块中的代码(用fcode代称一下)，不论try或者catch是否运行，fcode都会在它们(try和catch块)运行之后运行。注意一下这里有个特别的情况，就是如果try或者catch里面有return语句，finally里面的代码块fcode会在return语句执行之前执行。因为一个方法在执行return语句后就会被销毁。 finally它常常用来清理资源，大家应该会在使用jdbc连接数据库的时候用到。 finalize 它是方法名，大家或许有可能在看垃圾回收的地方看到过，没错，它确实和垃圾回收有一些关系。 使用finalize()方法在t(代称，后面有解释，便于理解)时之前做出必要的清理工作。这里的t是指垃圾收集器将对象从内存中清除出去。而什么时候调用呢？是在t1时(即在垃圾回收器确定这个对象没有被引用时，决定删除这个对象之前)对这个对象调用的。在Object类中定义的，所有的类都继承了它。 看到这里应该都对这三个英文单词有比较深的理解了吧，如果还不理解或者发现文中哪里有什么问题的，欢迎在下面留言，大家一起讨论，帮助更多的人！","categories":[{"name":"Java","slug":"Java","permalink":"http://panhainan.github.io/categories/Java/"}],"tags":[{"name":"Java关键字","slug":"Java关键字","permalink":"http://panhainan.github.io/tags/Java关键字/"},{"name":"final*","slug":"final","permalink":"http://panhainan.github.io/tags/final/"}]},{"title":"扯扯我的程序员之路（待续）","slug":"扯扯我的程序员之路（待续）","date":"2015-04-19T14:25:09.000Z","updated":"2019-09-30T18:49:29.805Z","comments":true,"path":"2015/04/19/扯扯我的程序员之路（待续）/","link":"","permalink":"http://panhainan.github.io/2015/04/19/扯扯我的程序员之路（待续）/","excerpt":"首先说明一下，这是本人瞎扯的文字记录，没有文笔可言，如果觉得自己有时间，可以打发一下无聊的时间，那么可以进来看看；如果觉得有兴趣，也可以进来看看；不过不要喷，这只是我个人的扯谈，没必要纠结于某个点。好了，有兴趣你就进来看吧，一起扯扯淡。","text":"首先说明一下，这是本人瞎扯的文字记录，没有文笔可言，如果觉得自己有时间，可以打发一下无聊的时间，那么可以进来看看；如果觉得有兴趣，也可以进来看看；不过不要喷，这只是我个人的扯谈，没必要纠结于某个点。好了，有兴趣你就进来看吧，一起扯扯淡。 好似命运安排的进入计算机专业 进了长沙理工的计算机专业，还记得我的第一志愿的六专业，前面五个选的都是土木，最后一个选的计算机，而且当时只是觉得这个名字很顺眼，然后选了，然后就进了。真的就是一句话说的那样“人生的每一天或许都是连续的奇迹”，只是我们没有在意而已。哈哈，当然后面这句是我加的，实话说原句我记不清了，好像是比我说的优雅多了，语文是硬伤，可能用词不当，见谅！ 总之，我觉得我来到计算机这个专业确实好似命运安排，当时我什么都不懂，哈哈，现在也还有很多都不懂。当时我是软件都不敢装的，从没有想过进这个专业啊。但是就是进了，而且或许这就是一辈子。 曾经也因C疯狂过 我在大一的刚开始的时候接触的C语言，当时想着能不能转到土木去，要求是要学院的前几名，于是乎开始了我的疯狂学C语言的路——刷ACM题库，当然，同时也在好好的学习其他的课程。还记得当时学校还不让带电脑（其实我当时也没电脑），于是乎411的3个疯子每天跑到机房去敲代码，同时还把一些题目整理弄在自己的手机里面，每天晚上躺在床上还在想解题的算法。3个人，当时宣子YX是最厉害的，杀进了第一，我中间，三哥GEL稍微我后面，也都是在前20之内。当时就是年少的那股冲劲，觉得上榜就是一件很了不起的事情。当时刷题是我们宿舍一件很疯狂的事情，不过还有一件更疯狂的事情——QQ飞车，4个人（加上阿伟WW）疯狂的组队玩了几个星期。哈哈，偶尔想起来还是挺怀念那段岁月的。 决定走出我的程序员之路的第一步 大一下学期学院开设的实验室招新，当时我们都不知道那是干嘛的，没什么概念，只是看着一个个老师在讲台上讲了一段话，然后走了，然后就会有一部分同学跟着出去，记得当时自己很傻比的坐到了最后一两个，而且还是没有搞懂情况的那种，特别二。后面发现不对了，然后就跟着其他同学出去了，问了一下，懂了一点点，知道是那些老师要带学生学习。于是我当时有了一个想法，找个想法其实不是当时产生的，是大一第一个学期结束后产生的，就是不打算转专业了，继续我的程序员之路——搞Android开发。当时就去找搞安卓的老师去了，而且也让我找到了，我还登记了，最后那个老师说等一个星期后等消息，然后就让我们走了。然后我就走了，抱着希望的走了。路上遇到玩的熟的同学，他说他在某某实验室，说老师还不错，挺好的，也是搞Java的，应该跟安卓也有关系，让我也一起去，当时我也跟着去了，认识了那个老师——汤老师TQ（最开始是叫企业信息系统快速开发实验室的指导老师，后面实验室改名叫叫“梦之站”，对校内也叫“Java创新性实验室”），确实是挺好的一个老师。搞完后和室友们高高兴兴的回去了，回去等消息。 其实那时候我和室友已经算是加了一个实验室的了，就是ACM实验室，当时参加了ACM校赛，拿了个二等还是三等忘记了，只记得当时老师是说拿了奖的建议加入ACM队，其实后面才知道也是ACM实验室。后面一天参见了当时汤老师的那个实验室的，接到了汤老师的电话，问了我和室友宣子一个选择性的问题——“你们已经进入了ACM实验室，如果你还想进入我们（汤老师负责的实验室）这边的话可能需要你退出那边的实验室，因为没有那么多的时间搞两个方向的。” 二选一，当时挺纠结的，想搞算法，同时也想搞Java，而且感觉汤老师人挺好交流的。和宣子商量了好一会，最后决定去汤老师这边，然后我只好尴尬的和ACM实验室的负责人（当时是一个学长负责管理我们的，FFQ学长，ACM也是挺强的）交流了一下，退出了ACM，当时确实是很对不起ACM那边的。其实为什么没有选ACM是这样的，虽然当时也比较喜欢刷题，但是在和宣子商量的时候（当时我们其他人的知识面没有萱子的广，没有他看问题看的深一些，于是乎很多时候都是和他一起讨论的，主要听取他分析的），宣子说算法搞下去的话后面很难，毕竟是造轮子。于是乎我们去了汤老师那边，但是为什么没有去最开始说的那个搞Android的呢？可能这也是奇迹吧，当时那个老师说等消息，大概一个星期左右，然后一直没消息（其实我当时的成绩挺好的，专业里面前五吧），就觉得这个老师不是很靠谱，而且还有点不爽，哈哈。后面的事实证明确实是不靠谱，因为我们班的大B哥PJL后面进的是他的实验室，但是后面大B哥说他基本上不怎么管，就是一个打酱油的老师，不靠谱。哈哈，算是奇迹吧。 开启我的Java旅行之路 在进汤老师的实验室后的两个星期，任务是学习Java，当时和我们班的捉鸡哥LXL是跟着一个学长的，也就是我们的师父WMS（这个简写有可能会百度到哦，他是一个在技术上很跟的上潮流的一个技术宅啊），那个学长也是实验室中最强的了，一直带我到大二结束，现在进了网易，时不时的还在联系。我和鸡哥两个人，他是很早就接触计算机了，玩Windows98玩的飞起那种，不过学编程也是高考完的暑假学的，比起我还是牛逼多了。不过说起综合素质的话还是我来做师兄吧，继承师父衣钵的问题还是师弟牛逼些。也确实，捉鸡哥也算是一个技术宅吧，我就是那种把技术当做是混饭吃的一种手段，不过自己还是的把这个手段练得拿手啊，哈哈。 当时师父布置的任务是三个星期搞定Java，然后捉鸡哥为了一（zhong）件（shen）事（da）情（shi，后面跟我交代的，哈哈）在第十天的时候搞定了，然后做为师兄（当时还没这么认为）总是有点不爽的，于是乎我在第十四天搞定了。其实也就当时以为搞定了，其实只学习了Java基础篇，然后后面很长一段时间都没有搞过Java。然后苦逼的现在在补Java。 然后后面就是苦逼的一个一个阶段的学习Java Web开发，到大二的时候基本上师父不会安排任务了，就是我们自己瞎搞搞这搞搞那的，期间大一暑假跟着我的半个师父江哥FLJ（为什么说半个师父呢，名义上不算，但是他教会了我很多其他的东西，比如喝酒以及一些礼仪啊，做人的一些道理啊等等）。说道喝酒，我觉得江哥说的一句话挺对的，“男人之间交朋友在酒桌上来杯酒挺管用的”。我觉得不管会不会喝，起码得懂得还礼，不要为了自己不喝一杯酒而推迟掉别人敬的酒（如果你真的是不能喝这是例外，比如身体的问题的，但是可以以茶代酒以水代酒等等）。我挺后悔以前没有好好的向爷爷（爷爷没读多少书，但是做人的礼节都是很懂的）学习这些传统的精华文化，没有多陪陪爷爷，唉，不说这个，总之大家要好好珍惜眼前人。 作为一个搞计算机的，必须得折腾电脑 大二一年，自己就是折腾电脑。大一的时候不会装系统，老同学电脑出问题了找我没帮上忙，就是给他们一个不靠谱的形象。于是乎大二各种折腾，装系统，玩虚拟机，玩Linux（这个当时纯属装逼，哈哈），玩各种软件等等。在Java Web这条路上大二一年没走几步。不过在大二的后期还是自己试着整个一个项目，也就是我的处女作啊——DS-Java论坛。这个可以去我的github上看到介绍。不过当时很遗憾没有整成功，有个bug，直到后面暑假重构的时候才搞定。 关于帮别人解决电脑问题，我这里有一招，大家可以学学，江哥教的，就是别人找你解决电脑问题，先不要说不会，可以先去百度，然后把找到的方法告诉对方，看能不能解决，能解决你就赚大了，哈哈。不过最好的还是自己多折腾一下，遇到的问题多了，经验也就多了，千万不要百度到的都是对方百度过的，这样就被拆穿了啊 梦之站DS的一群屌丝DS们，都在为自己成为大神DS的路上奋斗 在梦之站，还结识了其他几个好学长学姐，人都挺好一个的，现在有毕业的有快毕业的，都是玩的挺好的。有斌哥CB，凯哥ZK，二哥JM，嫩鸡哥CMM，老大WZJ，文哥WTW，胖子哥JYL，还有小明ZF等等。一下都想不起来了，对哦，还有设艺学院的几个学长学姐，天哥HJT，牛姐NYX，解姐JBL等等。这里祝愿他们都有一个好的未来。 在实验室慢慢的就混到了大三，但是待到大三的最开始的一批人越来越少。萱子大二的时候转到电气去了，还是同一宿舍；捉鸡哥大二后面基本上就没去（zai）实（guo）验（hao）室（ri）了（zi）；本来撑到最后的谢学霸XL感觉自己学不好，去参加培训了；还有好几个都慢慢的从身边消失了，然后实验室又回归了冷清的状态，现在侯哥HRZ一般不去了，我也是，偶尔去去。还有三个在用台式机的家伙在苦苦支撑着大力FDL，乐汇WLH，跃龙CLY；不过我们仍然在走程序员的路，仍然是一群好哥们，只是到了该分别的季节了，说不定以后还是会聚在一起创业呢。时间过得好快啊，悄悄的身边的人和物都换了，一点点感伤。 可能，这是最后，可能，这也是开始 现在，宿舍还是原来的四个人，不过回不去以前的样子了，而且马上就要各奔向各自未来的路去了，萱子阿伟考研，三哥和我就业。三哥玩的一手好Linux，搞得是嵌入式偏软件开发方向，而我呢，搞Java，起码最近几年是搞Java。 大学三年过去了，还有一年就要毕业了（但是这一年完全就不算是一年），其实我们算是马上就毕业了，要找工作了。这段时间，在整我的Java，整的有点烦的时候就看看Java Web，整整框架，又或者整整博客，就是这里，这两天整的成果，个人觉得还行。总之，我还在程序员的路上，可能这一辈都在程序员的这条路上。 不管怎样，要做好人生中的一些重要的决定，可能这个决定就会影响你一辈子，就像我决定走程序员这条路一样。记住，决定了，就要好好走下去！","categories":[{"name":"这里有酒有故事","slug":"这里有酒有故事","permalink":"http://panhainan.github.io/categories/这里有酒有故事/"}],"tags":[{"name":"故事","slug":"故事","permalink":"http://panhainan.github.io/tags/故事/"}]}]}